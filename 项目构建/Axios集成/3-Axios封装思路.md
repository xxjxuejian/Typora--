### **ä¸­åå°ç³»ç»Ÿçš„å¸¸è§„è®¾è®¡ï¼š**

- è·¯ç”±å®ˆå«ï¼šè´Ÿè´£åˆ¤æ–­ token æ˜¯å¦å­˜åœ¨ã€æœ‰æ•ˆã€æ˜¯å¦éœ€è¦åŠ¨æ€æ³¨å†Œè·¯ç”±
- è¯·æ±‚æ‹¦æˆªå™¨ï¼šåªè´Ÿè´£é™„åŠ  token
- å“åº”æ‹¦æˆªå™¨ï¼šè´Ÿè´£å¤„ç† token è¿‡æœŸï¼ˆ401ï¼‰å¹¶åšç»Ÿä¸€è¡Œä¸º



### ğŸ§© **ç»“è®ºå…ˆè¯´ï¼šè¯·æ±‚æ‹¦æˆªå™¨é‡Œä¸€èˆ¬ ä¸éœ€è¦ åˆ¤æ–­ token æ˜¯å¦å­˜åœ¨æˆ–è¿‡æœŸ**

è¿™ä¸æ˜¯å·æ‡’ï¼Œè€Œæ˜¯**èŒè´£æ‹†åˆ†**å¯¼è‡´çš„ç»“æœã€‚
 æ¯ä¸ªæ¨¡å—åªåšå±äºè‡ªå·±çš„é‚£ä¸€éƒ¨åˆ†ï¼Œä¸æâ€œä¸€é”…ç‚–â€ã€‚



### ğŸ§­ ä¸ºä»€ä¹ˆè¯·æ±‚æ‹¦æˆªå™¨é‡Œä¸åˆ¤æ–­ token æœ‰æ•ˆæ€§ï¼Ÿ

#### âœ” 1. **è·¯ç”±å®ˆå«è´Ÿè´£æ§åˆ¶â€œæ˜¯å¦èƒ½è¿›é¡µé¢â€**

è·¯ç”±å®ˆå«æ˜¯â€œé—¨å«â€ï¼š

- ä½ æœ‰æ²¡æœ‰ tokenï¼Ÿ
- token è¿˜è¡Œä¸è¡Œï¼Ÿ
- æ²¡ token å°±é€ä½ å»ç™»å½•é¡µã€‚

è¿™æ˜¯é¡µé¢çº§åˆ«çš„æƒé™ã€‚

å®ƒçš„èŒè´£å°±æ˜¯ï¼š
 **ä¸ç»™ä½ çœ‹åˆ°ä¸è¯¥çœ‹çš„é¡µé¢ã€‚**
 ç½‘ç»œè¯·æ±‚å‘ç”Ÿä¸å‘ç”Ÿï¼Œé‚£æ˜¯åé¢çš„äº‹ã€‚

------



#### âœ” 2. ç½‘ç»œè¯·æ±‚æ‹¦æˆªå™¨åªè´Ÿè´£ä¸€ä¸ªäº‹ï¼šæŠŠ token å¸¦ä¸Š**

æ‹¦æˆªå™¨ä¸»è¦èŒè´£ï¼š

- ç»™è¯·æ±‚åŠ ä¸Š Authorization å¤´
- åšäº›å…¬å…±å‚æ•°
- æ”¹ä¸ª content-type ä¹‹ç±»çš„

å®ƒåƒâ€œæŒ‚ä»¶â€ï¼Œ**ä¸åšæƒé™æ§åˆ¶**è¿™ç§å¤§äº‹ã€‚

å¦‚æœä½ è®©å®ƒä¹Ÿåš token æ ¡éªŒï¼Œä¼šå‡ºç°â€œè·¯ç”±å®ˆå« + è¯·æ±‚æ‹¦æˆªå™¨åŒæ—¶åˆ¤æ–­ token çš„æ··ä¹±å±€é¢â€ã€‚

è€Œä¸”ä¼šè®©è¯·æ±‚æ‹¦æˆªå™¨é€»è¾‘å˜å¾—è‡ƒè‚¿ã€‚

------



#### âœ” 3. **åˆ¤æ–­ token æ˜¯å¦è¿‡æœŸæ˜¯åç«¯çš„è´£ä»»**

å³ä¾¿å‰ç«¯åšäº†â€œæœ¬åœ°è¿‡æœŸæ—¶é—´åˆ¤æ–­â€ï¼Œåç«¯ä¹Ÿå¿…é¡»åˆ¤æ–­ã€‚ä¸ç„¶å¤ªå±é™©ã€‚

æ‰€ä»¥å¾ˆå¤šä¸­åå°é¡¹ç›®ç›´æ¥è®©åç«¯è¿”å› 401ï¼Œç„¶åç»Ÿä¸€å¤„ç†ã€‚

ğŸ‘‰ **é”™è¯¯æ‹¦æˆªå™¨** æ‰æ˜¯å¤„ç† token è¿‡æœŸçš„åœ°æ–¹ï¼ˆå“åº”æ‹¦æˆªå™¨ï¼‰
 ï¼ˆè€Œä¸æ˜¯è¯·æ±‚æ‹¦æˆªå™¨ï¼‰

é€šå¸¸é€»è¾‘æ˜¯è¿™æ ·çš„ï¼š

##### ğŸ§± è¯·æ±‚æ‹¦æˆªå™¨

åªåŠ å¤´ï¼š

```js
if (token) {
  config.headers.Authorization = `Bearer ${token}`
}
```

##### ğŸ§± å“åº”æ‹¦æˆªå™¨

ç»Ÿä¸€åˆ¤æ–­ token æ˜¯å¦è¿‡æœŸï¼š

```js
if (res.code === 401) {
  logout();
  redirectToLogin();
}
```

è¿™ä¹Ÿæ˜¯ç»å¤§å¤šæ•°å¼€æºåå°æ¡†æ¶çš„å¥—è·¯ã€‚





å“åº”æ‹¦æˆªå™¨

```js
service.interceptors.response.use(
  /** ç¬¬ä¸€ä¸ªå‡½æ•°ï¼ˆæˆåŠŸçš„å“åº”ï¼‰ */
  (response) => {
    // ...
  },

  /** ç¬¬äºŒä¸ªå‡½æ•°ï¼ˆå¤±è´¥çš„å“åº”ï¼‰ */
  (error) => {
    // ...
  }
)
```

âœ… ç¬¬ä¸€ä¸ªå‡½æ•°è§¦å‘çš„æ¡ä»¶

**åªè¦æœåŠ¡å™¨æˆåŠŸè¿”å›äº†å“åº”ï¼ˆHTTP çŠ¶æ€ç ä¸º 2xx æˆ– 3xxï¼‰å°±ä¼šè§¦å‘**ï¼Œå³ä½¿ä¸šåŠ¡ä¸Šæ˜¯å¤±è´¥çš„ã€‚

```json
HTTP 200 OK
{
  "code": 400,
  "msg": "æ— æƒé™è®¿é—®",
  "data": null
}
```

è¿™ç§æƒ…å†µï¼Œ**HTTP å±‚æ˜¯æˆåŠŸçš„ï¼ŒAxios ä¼šè¿›å…¥ç¬¬ä¸€ä¸ªå‡½æ•°**ï¼Œä½ éœ€è¦åœ¨è¿™é‡Œå¤„ç†ä¸šåŠ¡å¤±è´¥çš„ `code !== 200` æƒ…å†µã€‚



âŒ ç¬¬äºŒä¸ªå‡½æ•°è§¦å‘çš„æ¡ä»¶

**åªæœ‰åœ¨ HTTP å±‚å‡ºé”™æ—¶æ‰ä¼šè§¦å‘**ï¼Œæ¯”å¦‚ï¼š

- ç½‘ç»œå¼‚å¸¸ï¼ˆæ–­ç½‘ã€è¶…æ—¶ï¼‰
- è¯·æ±‚è¢«å–æ¶ˆ
- HTTP çŠ¶æ€ç æ˜¯ï¼š
  - `400 Bad Request`
  - `401 Unauthorized`
  - `403 Forbidden`
  - `404 Not Found`
  - `500 Internal Server Error`
  - å…¶ä»–é 2xx çŠ¶æ€ç 

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œ**Axios ä¸ä¼šèµ°ç¬¬ä¸€ä¸ªå‡½æ•°ï¼Œç›´æ¥èµ°ç¬¬äºŒä¸ªå‡½æ•°çš„ `error` åˆ†æ”¯**ã€‚





### ğŸš€ **å¸¸ç”¨ axios å°è£…ç¤ºä¾‹**



ä½¿ç”¨åˆ·æ–° token (refresh token) ä½“ç³»

`accessToken` æœ‰æ•ˆæœŸå¾ˆçŸ­

`refreshToken` è‡ªåŠ¨ç»­æœŸ

`src/utils/request.ts`

```ts
import axios, { type InternalAxiosRequestConfig, type AxiosResponse } from "axios";
import qs from "qs";
import { useUserStoreHook } from "@/store/modules/user.store";
import { ResultEnum } from "@/enums/api/result.enum";
import { getAccessToken } from "@/utils/auth";
import router from "@/router";

// åˆ›å»º axios å®ä¾‹
const service = axios.create({
  baseURL: import.meta.env.VITE_APP_BASE_API,
  timeout: 50000,
  headers: { "Content-Type": "application/json;charset=utf-8" },
  paramsSerializer: (params) => qs.stringify(params),
});
// è¯·æ±‚æ‹¦æˆªå™¨
service.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const accessToken = getAccessToken();
    // å¦‚æœ Authorization è®¾ç½®ä¸º no-authï¼Œåˆ™ä¸æºå¸¦ Token
    if (config.headers.Authorization !== "no-auth" && accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    } else {
      delete config.headers.Authorization;
    }
    return config;
  },
  (error) => Promise.reject(error)
);
// å“åº”æ‹¦æˆªå™¨
service.interceptors.response.use(
  (response: AxiosResponse) => {
    // å¦‚æœå“åº”æ˜¯äºŒè¿›åˆ¶æµï¼Œåˆ™ç›´æ¥è¿”å›ï¼Œç”¨äºä¸‹è½½æ–‡ä»¶ã€Excel å¯¼å‡ºç­‰
    if (response.config.responseType === "blob") {
      return response;
    }
    const { code, data, msg } = response.data;
    if (code === ResultEnum.SUCCESS) {
      return data;
    }
    ElMessage.error(msg || "ç³»ç»Ÿå‡ºé”™");
    return Promise.reject(new Error(msg || "Error"));
  },
  async (error) => {
    console.error("request error", error); // for debug
    const { config, response } = error;
    if (response) {
      const { code, msg } = response.data;
      if (code === ResultEnum.ACCESS_TOKEN_INVALID) {
        // Token è¿‡æœŸï¼Œåˆ·æ–° Token
        return handleTokenRefresh(config);
      } else if (code === ResultEnum.REFRESH_TOKEN_INVALID) {
        // åˆ·æ–° Token è¿‡æœŸï¼Œè·³è½¬ç™»å½•é¡µ
        await handleSessionExpired();
        return Promise.reject(new Error(msg || "Error"));
      } else {
        ElMessage.error(msg || "ç³»ç»Ÿå‡ºé”™");
      }
    }
    return Promise.reject(error.message);
  }
);
export default service;
// æ˜¯å¦æ­£åœ¨åˆ·æ–°æ ‡è¯†ï¼Œé¿å…é‡å¤åˆ·æ–°
let isRefreshing = false;
// å›  Token è¿‡æœŸå¯¼è‡´çš„è¯·æ±‚ç­‰å¾…é˜Ÿåˆ—
const waitingQueue: Array<() => void> = [];
// åˆ·æ–° Token å¤„ç†
async function handleTokenRefresh(config: InternalAxiosRequestConfig) {
  return new Promise((resolve) => {
    // å°è£…éœ€è¦é‡è¯•çš„è¯·æ±‚
    const retryRequest = () => {
      config.headers.Authorization = `Bearer ${getAccessToken()}`;
      resolve(service(config));
    };
    waitingQueue.push(retryRequest);
    if (!isRefreshing) {
      isRefreshing = true;
      useUserStoreHook()
        .refreshToken()
        .then(() => {
          // ä¾æ¬¡é‡è¯•é˜Ÿåˆ—ä¸­æ‰€æœ‰è¯·æ±‚, é‡è¯•åæ¸…ç©ºé˜Ÿåˆ—
          waitingQueue.forEach((callback) => callback());
          waitingQueue.length = 0;
        })
        .catch(async (error) => {
          console.error("handleTokenRefresh error", error);
          // åˆ·æ–° Token å¤±è´¥ï¼Œè·³è½¬ç™»å½•é¡µ
          await handleSessionExpired();
        })
        .finally(() => {
          isRefreshing = false;
        });
    }
  });
}
// å¤„ç†ä¼šè¯è¿‡æœŸ
async function handleSessionExpired() {
  ElNotification({
    title: "æç¤º",
    message: "æ‚¨çš„ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•",
    type: "info",
  });
  await useUserStoreHook().clearSessionAndCache();
  router.push("/login");
}
```







