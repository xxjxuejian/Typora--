### 单图上传组件：

#### 最终效果

![image-20251119174200651](./../../typora-pic/image-20251119174200651.png)

点击图片，即可上传图片，

点击右上角删除图标，即可删除图片



#### 使用场景：

某一个页面加载时要获取已经上传的图片，显示在页面上，后端返回的可能是一个图片`Url`，或者一个资源的`id`，再利用`id`生成`url`。

当前项目中后端返回的是一个图片资源`id`,根据这个`id`回显图片，如果点击图片可以重新上传，会覆盖之前的图片，点击删除按钮，可以删除图片。

#### 使用方式：

这个组件的最终效果是，在父组件中使用这个图片上传子组件，通过`v-model`使用，

```vue
<ImageUpload
  v-model="form.banner"
  tips="请使用 宽780 像素* 高140 像素内的JPG,GIF,PNG透明图片。"
  width="780px"
  height="140px"
></ImageUpload>
```

图片更新或者删除，会同步更新这个`form.banner`值。



#### 封装组件：

思路：

既然需要通过`v-mode`进行双向绑定，说明子组件需要定义`props: modelValue`，接收来自父组件的值，可以做到父组件的`form.banner`改变时，这个`modelValue`一起改变。

但是子组件中也会删除图片或者更新图片，这就涉及到了修改这个`props: modelValue`，但是按照单向数据流原理， Vue 中 **`props` 是只读的，不能直接修改**。

所以还需要一个中间变量，他的值跟随`modelValue`变化，同时又可以修改。中间变量被修改时，意味着要更新父组件的`form.banner` ，这时又可以通知父组件进行更新。

这样的变量，可以定义为一个计算属性，带 `getter + setter` 的计算属性：

> （Vue3.4+ 可以使用`defineModel()`替代computed）

```vue
<script>
// 接收已经上传的文件id
const props = defineProps({
  modelValue: {
    default: ''
  },
})

const emits = defineEmits(['update:modelValue'])

const curImgId = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emits('update:modelValue', value)
  }
})    
</script>

<template>
  <!-- 在模板中，可以直接使用 props.modelValue -->
  <el-image
    v-if="props.modelValue"
    :src="`/seller.php?mode=resource_dump&resource_id=${props.modelValue}`"
  />
</template>
```

1， 父组件的`form.banner`改变  `-->`  子组件的`props:modelValue` 改变  `-->`  计算属性`curImgId`改变 `-->`   `el-image`的`src`值改变 `-->`  图片更新

2，上传图片：

上传成功以后，会返回新的图片的`id`,赋值 给`curImgId`，

```js
const handleSuccess = (response) => {
  if (response?.error === 0 && response.resource_id) {
    curImgId.value = response.resource_id // 保存当前图片的ID
  }
}
```

这时候修改`curImgId.value`，触发其`set`方法，发送`update:modelValue`事件

父组件会更新`form.banner`，接着会同步更新给子组件的`props：modelValue`，最终导致图片更新，同时父组件中也保存了最新的`id`

3， 删除图片：

```js
/**
 * 删除图片
 */
const handleRemove = async () => {
  const id = curImgId.value // 使用当前图片的ID
  if (!id) {
    ElMessage.warning('没有可删除的图片')
    return
  }
  const res = await deleteResourceApi(id)
  if (res) {
    ElMessage.success('删除成功')
    curImgId.value = '' // 清空当前图片ID
  }
}
```

删除图片就是把当前的`curImgId`对应的图片删除，成功调用接口以后，

```js
curImgId.value = '' // 清空当前图片ID
```

触发`curImgId`的`set()`，触发`emits`，父组件会更新`form.banner`，接着会同步更新给子组件的`props：modelValue`，最终导致图片清除，同时父组件的`form.banner`也是`''`。



#### 完整代码：

`SingleImageUpload.vue`

```vue
<script setup>
import { addResourceApi, deleteResourceApi } from '@/api/productManage/productRelease.js'

// 接收已经上传的文件ids,回显
const props = defineProps({
  /**
   * 双向绑定的值 (图片URL)
   */
  modelValue: {
    default: ''
  },
  /**
   * 上传图片的提示信息
   */
  tips: {
    type: String,
    default: '请选择图片上传,支持jpg,jpeg,webp,png,gif格式'
  },
  /**
   * 上传图片格式，默认支持所有图片(image/*)，指定格式示例：'.png,.jpg,.jpeg,.gif,.bmp'
   */
  accept: {
    type: String,
    default: 'image/*'
  },
  /**
   * 最大文件大小（单位：M）
   */
  maxFileSize: {
    type: Number,
    default: 5
  },
  /**
   * 设置组件的宽度和高度
   */
  width: {
    type: String,
    default: '150px'
  },
  height: {
    type: String,
    default: '150px'
  }
})

const emits = defineEmits(['purge', 'update:modelValue'])
const uploadRef = ref(null) // 用于获取上传组件的引用
const curImgId = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emits('update:modelValue', value)
  }
})

/**
 * 限制用户上传文件的格式和大小
 */
function handleBeforeUpload(file) {
  // 校验文件类型：虽然 accept 属性限制了用户在文件选择器中可选的文件类型，但仍需在上传时再次校验文件实际类型，确保符合 accept 的规则
  const acceptTypes = props.accept.split(',').map((type) => type.trim())

  // 检查文件格式是否符合 accept
  const isValidType = acceptTypes.some((type) => {
    if (type === 'image/*') {
      // 如果是 image/*，检查 MIME 类型是否以 "image/" 开头
      return file.type.startsWith('image/')
    } else if (type.startsWith('.')) {
      // 如果是扩展名 (.png, .jpg)，检查文件名是否以指定扩展名结尾
      return file.name.toLowerCase().endsWith(type)
    } else {
      // 如果是具体的 MIME 类型 (image/png, image/jpeg)，检查是否完全匹配
      return file.type === type
    }
  })

  if (!isValidType) {
    ElMessage.warning(`上传文件的格式不正确，仅支持：${props.accept}`)
    return false
  }

  // 限制文件大小
  if (file.size > props.maxFileSize * 1024 * 1024) {
    ElMessage.warning('上传图片不能大于' + props.maxFileSize + 'M')
    return false
  }
  return true
}
// 上传函数，如果多选也是执行多次，
const handleUpload = async (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)

    addResourceApi(formData)
      .then((data) => {
        console.log('image上传完成', data)
        resolve(data)
      })
      .catch((error) => {
        reject(error)
      })
  })
}

const handleSuccess = (response) => {
  if (response?.error === 0 && response.resource_id) {
    curImgId.value = response.resource_id // 保存当前图片的ID
  }

}

/**
 * 删除图片
 */
const handleRemove = async () => {
  const id = curImgId.value // 使用当前图片的ID
  if (!id) {
    ElMessage.warning('没有可删除的图片')
    return
  }
  const res = await deleteResourceApi(id)
  if (res) {
    ElMessage.success('删除成功')
    curImgId.value = '' // 清空当前图片ID
  }
}
const handleError = (error) => {
  console.error(error)
  ElMessage.error('上传失败: ' + error.message)
}
</script>

<template>
  <div>
    <div>
      <el-upload
        ref="uploadRef"
        accept="image/png, image/jpeg, image/gif,image/jpg,image/webp"
        class="single-upload"
        list-type="picture-card"
        :show-file-list="false"
        :before-upload="handleBeforeUpload"
        :http-request="handleUpload"
        :on-success="handleSuccess"
        :on-error="handleError"
      >
        <template #default>
          <!-- 在模板中，可以直接使用 props.modelValue -->
          <el-image
            v-if="props.modelValue"
            :src="`/seller.php?mode=resource_dump&resource_id=${props.modelValue}`"
          />
          <el-icon
            v-if="props.modelValue"
            @click.stop="handleRemove"
            class="single-upload__delete-btn"
          >
            <CircleCloseFilled />
          </el-icon>

          <el-icon v-else class="single-upload__add-btn">
            <Plus />
          </el-icon>
        </template>
      </el-upload>
    </div>

    <div class="text-[#939393] text-sm mt-2">
      {{ props.tips }}
    </div>
  </div>
</template>

<style lang="scss" scoped>
:deep(.el-upload--picture-card) {
  /*  width: var(--el-upload-picture-card-size);
  height: var(--el-upload-picture-card-size); */
  width: v-bind('props.width');
  height: v-bind('props.height');
  --el-upload-picture-card-size: none;
  border: none;
}

.single-upload {
  width: v-bind('props.width');
  position: relative;
  overflow: hidden;
  cursor: pointer;
  border: 1px var(--el-border-color) solid;
  border-radius: 5px;

  &:hover {
    border-color: var(--el-color-primary);
  }

  &__delete-btn {
    position: absolute;
    top: 1px;
    right: 1px;
    font-size: 16px;
    color: #ff7901;
    cursor: pointer;
    background: #fff;
    border-radius: 100%;

    :hover {
      color: #ff4500;
    }
  }
}
</style>

```



#### 自动上传

`auto-upload`：是否自动上传文件，默认值  `true`

它的作用是

如果值为`true`时，我们打开文件管理器选中一张图片，点击打开以后，就会自动上传到后端服务器

![image-20251119161059899](./../../../笔记/typora-pic/image-20251119161059899.png)



而如果，我们需要先选择了一张图片，然后点击上传按钮，进行上传，这种情况先，就需要设置

`auto-upload = false`

在点击上传按钮时，再执行上传逻辑。



#### 上传文件数量

`limit` ： 允许上传文件的最大数量

不设置默认是`1`，选择文件的时候只能选择一张图片

#### 上传文件之前

上传文件之前的钩子

`:before-upload="handleBeforeUpload"`

上传文件之前的钩子，参数为上传的文件， 若返回`false`或者返回` Promise` 且被 reject，则停止上传。

看下这个选中文件以后，上传文件之前，这个文件对象的结构是什么样的

```js
function handleBeforeUpload(file) {
  console.log('上传之前的文件对象', file)
  return false
}
```

![image-20251119161905422](./../../../笔记/typora-pic/image-20251119161905422.png)

##### 执行的逻辑

上传文件之前做的操作就是**限制用户上传文件的格式和大小**

根据可接收的文件类型`acceptTypes`，这个值可以事先定义好，也可以通过`prop`传递

- 检查文件格式是否符合 `acceptTypes`
- 限制文件大小

返回值`true/false`，则决定了能否继续下去



#### 上传文件

`http-request` ： 覆盖默认的 Xhr 行为，允许自行实现上传文件的请求

`:http-request="handleUpload"`

通常都会自行实现，这里进行实际的调用后端接口上传

```js
const handleUpload = async (options) => {}
```

这里会传递一个`options`参数

这个函数必须要返回一个`promise`，调用上传接口以后，更新promise状态

`resolve`则认为是上传成功，执行`on-success`的回调

`reject`则认为是上传失败，执行`on-error`的回调

```js
// 上传函数，如果多选也是执行多次，
const handleUpload = async (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)

    addResourceApi(formData)
      .then((data) => {
        console.log('image上传完成', data)
        resolve(data)
      })
      .catch((error) => {
        reject(error)
      })
  })
}
```

`options.file`就是上传的文件对象

上传成功`resolve(data)`，这个`data`对象结构如下

这是由后端定义的返回的数据，我们这里返回的关键点是这个`resource_id`，

其它情况可能返回一个`url`，由后端来决定。

```json
{
    "resource_id": 198,
    "file_key": "bf0a1a7a85679eed5e18793b86bc7152",
    "error": 0,
    "tmp_name": "/tmp/phpETrj1Q",
    "name": "tip_3.png",
    "type": "image/png",
    "mime_type": "image/png",
    "create_time": 1763543236,
    "file_object": {
        "name": "tip_3.png",
        "type": "image/png",
        "tmp_name": "/tmp/phpETrj1Q",
        "error": 0,
        "size": 1147
    }
}
```

这个data对象会传递到`on-success`的回调函数作为参数



#### 上传成功

```js
const handleSuccess = (response) =>{
    console.log('上传成功-----------------')
    console.log('响应', response)
}
```

这里的`response`参数就是之前的`resolve(data)`中的`data`，他们是同一个对象

模拟代码如下：

```js
const handleUpload = (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)
	
     // 定时器1s后 resolve一个对象，表示后端的返回
    setTimeout(() => {
      resolve({
        msg: '模拟上传成功',
        error: 0,
        info: '666'
      })
    }, 1000)
  })
}

// on-success的回调
const handleSuccess = (response) => {
  console.log('上传成功-----------------')
  console.log('响应', response)

  console.log('上传成功-----------------')
}


```

输出

![image-20251119171917303](./../../../笔记/typora-pic/image-20251119171917303.png)

可以发现`on-success`的回调中的`response`就是我们模拟的一个对象



#### 上传失败

```js
const handleUpload = (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)

    setTimeout(() => {
      reject({
        msg: '模拟上传失败',
        error: 1,
        info: 'xxx'
      })
    }, 1000)
      
  })
}
// on-error回调
const handleError = (error) => {
    console.log('上传失败+++++++++++++')
    console.error(error)
    console.log('上传失败+++++++++++++')
}
```

输出

![image-20251119172854853](./../../../笔记/typora-pic/image-20251119172854853.png)

可以发现`on-error`的回调中的`error`就是我们模拟的对象

