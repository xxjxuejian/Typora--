### 📌 什么是埋点上报

**埋点（Tracking Point）** 指的是在代码里人为加上一些“记录用户行为”的代码逻辑，然后把这些行为数据发送（上报）到服务器。

比如：

- 用户点击了某个按钮
- 用户下载了一张图片
- 用户停留在某个页面多久
- 用户支付成功

这些数据对 **产品、运营、业务分析** 非常有用。



### 📌 应用场景

1. **用户行为分析**
   - 比如「每天有多少人点击下载按钮」
   - 「哪张图片最受欢迎」
   - 「某个功能使用率是多少」
2. **业务统计 / 计费**
   - 像你现在的 `downloadPicApi`，就可能用于统计图片的下载量
   - 如果这些图片是收费的，还可能跟收入挂钩
3. **AB 测试**
   - 发布两个版本的页面，统计哪个版本的转化率更高
   - 通过埋点判断最终采用哪个方案
4. **问题监控 / 日志分析**
   - 统计接口失败率、页面报错数
   - 分析某个功能是不是有 bug



### 📌 举个例子

你现在的流程是这样的：

```js
// 保存图片到相册
await saveImageToAlbum(imgInfo.path);
// 然后上报
downloadPicApi({ picId });
```

这里的 `downloadPicApi` 就是一个埋点上报接口：

- 用户下载了图片 → 上报到后台
- 后台可以知道这张图片被下载了多少次、谁下载的

如果不做这个上报，后台就完全不知道用户的行为。



### 📌 总结

- **埋点**：在关键行为处插入上报代码。
- **上报**：把埋点数据发送到后台，供分析/统计/计费。
- **应用**：用户行为分析、计费统计、AB测试、监控。



### 埋点上报实现

#### 1. 工具函数实现

`// utils/track.js`

```js
// 上报埋点的核心函数
async function sendReport(apiFn, params) {
  try {
    await apiFn(params); // 第一次尝试
  } catch (err) {
    console.warn("埋点上报失败，准备重试...", err);
    try {
      await apiFn(params); // 重试一次
    } catch (err2) {
      console.error("埋点重试失败，缓存到本地", err2);
      cacheReport({ apiFnName: apiFn.name, params });
    }
  }
}

// 缓存失败的埋点（存到本地）
function cacheReport(data) {
  const key = "pendingReports";
  const reports = uni.getStorageSync(key) || [];
  reports.push({ ...data, time: Date.now() });
  uni.setStorageSync(key, reports);
}

// 重新发送缓存的埋点
async function flushReports(apiMap) {
  const key = "pendingReports";
  const reports = uni.getStorageSync(key) || [];

  if (!reports.length) return;

  const successReports = [];
  for (const item of reports) {
    const apiFn = apiMap[item.apiFnName];
    if (!apiFn) continue; // 找不到对应接口就跳过
    try {
      await apiFn(item.params);
      successReports.push(item);
    } catch (err) {
      console.warn("补发失败", err);
    }
  }

  // 把成功的移除
  const remain = reports.filter((r) => !successReports.includes(r));
  uni.setStorageSync(key, remain);
}

export default {
  sendReport,
  flushReports,
};
```

这里缓存函数到本地时，缓存的仅仅是函数的名称，不是函数本身

```js
 cacheReport({ apiFnName: apiFn.name, params });
```

实际上，但在 **JavaScript/uniapp 环境里把函数本身缓存到本地存储**（`localStorage` / `uni.setStorageSync`）是行不通的。

**函数不能被序列化**

`uni.setStorageSync` / `localStorage` 底层其实是 **字符串存储**。

你往里面存对象时，它会先 `JSON.stringify`，但函数在 JSON 里会被丢弃。

```js
JSON.stringify({ fn: () => {} }) // => "{}"
```

所以函数无法直接存进去，再取出来的时候就丢失了。



所以在使用`flushReports`时，参数是一个映射表，即`函数名称：函数本身`，这样的一个映射表，根据函数名称获取函数本身，然后调用。

#### 2. 使用方式

假设你有一个接口：

```js
// api.js
export function downloadPicApi(params) {
  return new Promise((resolve, reject) => {
    uni.request({
      url: "https://example.com/api/download",
      method: "POST",
      data: params,
      success: (res) => {
        if (res.statusCode === 200) resolve(res.data);
        else reject(new Error("接口返回错误"));
      },
      fail: reject,
    });
  });
}
```

在业务代码里调用：

```js
import Track from "@/utils/track";
import { downloadPicApi } from "@/api";

// 图片保存成功后调用
Track.sendReport(downloadPicApi, { picId: 123 });
```

#### 3. 在合适的时机补发缓存

比如在 `App.vue` 的 `onLaunch` 里调用一次：

```js
import Track from "@/utils/track";
import { downloadPicApi } from "@/api";

export default {
  onLaunch() {
    // 补发本地缓存的埋点
    Track.flushReports({
      downloadPicApi,
    });
  },
};
```

```js
// 这里的参数是一个函数映射表，{ downloadPicApi : downloadPicApi },
Track.flushReports({
	downloadPicApi,
});
```



### ✅ 效果

1. **正常情况**：保存成功 → 上报成功。
2. **接口失败**：重试一次，如果还失败 → 缓存到本地。
3. **下次启动 App / 小程序**：会自动把缓存的埋点重新上报。





### 📌 常见导致埋点失败的情况

#### 1. **网络问题**

- 用户当前无网络 / 网络切换（WiFi → 4G）
- 弱网环境（延迟高，超时）
- 用户突然断网（锁屏、飞行模式、App 退后台）

👉 最常见的失败原因，也是为什么要做缓存。





#### 2. **服务端问题**

- 接口挂掉 / 502 / 503 / 500
- 域名解析失败 / CDN 故障
- 服务端限流（高峰期可能直接丢请求）

👉 这类失败一般是全局性的，你的埋点很可能需要等服务端恢复再补发。



#### 3. **CORS / 跨域问题（H5 特有）**

- 前端请求的埋点接口，后端没配置 `Access-Control-Allow-Origin`。
- 本地开发用 `http://192.168.x.x`，生产是 `https://xxx.com`，后端没允许跨域。

👉 你前几天遇到的 `CORS policy blocked` 就属于这种情况。



#### 4. **小程序 / App 特殊限制**

- 小程序请求域名没有在后台配置白名单。
- App 刚启动、WebView 环境还没初始化，导致请求失败。
- 部分平台（比如微信小程序）对请求有并发数限制（同时最多 10 个 request）。



#### 5. **埋点数据格式问题**

- 前端传的参数不符合后端要求，导致被 reject。
- 后端返回非 200 状态码（比如 400/401/403）。
- JSON 格式错误 / 乱码。

👉 这时候错误属于「可预期失败」，通常需要业务修正。



#### 6. **用户行为导致**

- 用户点击了下载，但瞬间关闭页面 / 退后台 → 请求被中断。
- 用户手动取消授权（比如保存到相册时拒绝授权），导致埋点逻辑没走下去。



#### 📌 总结

导致埋点失败的主要原因可以归类为三类：

1. **前端环境不稳定**
   - 网络断开、App 退后台、小程序限制。
2. **后端服务不稳定**
   - 接口挂了、跨域问题、限流。
3. **业务逻辑问题**
   - 参数错误、权限不足、用户取消操作。

👉 这也是为什么：

- 埋点通常 **不阻塞主流程**（比如保存成功照样提示用户）。
- 要有 **重试 + 缓存补发** 机制。



### 埋点失败场景 → 应对策略表格

| **失败场景**            | **原因描述**                                 | **业务影响**         | **应对策略**                                                 |
| ----------------------- | -------------------------------------------- | -------------------- | ------------------------------------------------------------ |
| **网络问题**            | 用户断网、弱网、飞行模式切换、App 退后台     | 请求失败，数据未上报 | - 本地缓存失败埋点  - 网络恢复或定时器自动补发  - 可加重试机制 |
| **服务端故障**          | 接口挂掉、返回 5xx、CDN / DNS 问题           | 请求失败，上报失败   | - 重试一次或多次  - 本地缓存等待下次补发  - 记录日志便于运维排查 |
| **跨域 / CORS**         | H5 域名未配置跨域允许                        | 浏览器直接阻止请求   | - 后端正确配置 `Access-Control-Allow-Origin`  - 本地开发时使用代理 |
| **小程序 / App 限制**   | 域名未白名单、并发请求限制、WebView 未初始化 | 请求失败，上报失败   | - 确保接口在小程序后台/manifest 配置白名单  - 控制并发请求  - 等待环境初始化后再发送 |
| **数据格式错误**        | 参数缺失、格式不符、JSON 错误                | 请求被服务端拒绝     | - 前端校验参数  - 修正请求数据  - 不缓存，直接丢弃           |
| **用户行为导致**        | 用户取消操作、拒绝权限、页面关闭             | 请求未发送或中断     | - 业务上无需补发（比如用户取消下载）  - 对关键行为，可提示重试或记录失败状态 |
| **接口限流 / 权限不足** | 高峰期接口返回 429 / 未授权                  | 上报失败             | - 本地缓存失败请求  - 等待下一次机会补发  - 可适当降低发送频率 |

#### 📌 使用建议

1. **缓存补发优先处理**：针对网络问题、服务端故障、接口限流等可恢复情况。
2. **不缓存可预期失败**：用户取消、参数错误等可直接丢弃或提示用户。
3. **统一封装埋点工具**：像前面写的 `Track.sendReport` + `flushReports`，保证主流程不受阻碍。
4. **日志记录**：补发失败可以打印日志，便于运维或分析问题。





### **埋点失败分两种**：

1. **可恢复失败**（网络问题、服务端挂了、限流） → ✅ 应该缓存，等待补发。
2. **不可恢复失败**（前端参数错误、业务逻辑不成立） → ❌ 不应该缓存，直接丢弃。

所以，`sendReport` 里需要在 **失败是区分错误类型**，不是所有失败都进缓存。

#### 📌 改进后的 `sendReport`

```js
async function sendReport(apiFn, params) {
    try {
        await apiFn(params); // 第一次尝试
    } catch (err) {
        console.warn("埋点上报失败，准备重试...", err);
        // 判断是否为“可恢复失败”
        if (isRetryableError(err)) {
            try {
                await apiFn(params); // 再重试一次
            } catch (err2) {
                console.error(`[埋点] 重试失败，写入缓存: ${apiFn.name}`, err2);
                cacheReport({ apiFnName: apiFn.name, params });
            }
        } else {
            console.error(`[埋点] 不可恢复失败，丢弃: ${apiFn.name}`, err);
        }

    }
}
```

#### 📌 辅助函数：判断错误类型

你可以封装一个 `isRetryableError` 来区分错误：

```js
function isRetryableError(err) {
  if (!err) return false;

  // 网络问题 / 超时
  if (err.errMsg && err.errMsg.includes("request:fail")) return true;

  // HTTP 状态码
  if (err.statusCode) {
    if (err.statusCode >= 500) return true; // 服务端错误，可重试
    if (err.statusCode === 429) return true; // 限流，可重试
    return false; // 4xx 参数错误等，直接丢弃
  }

  return false; // 默认不可重试
}
```

#### ✅ 这样改进后

- 网络失败、服务器挂了、限流 → 会缓存并补发。
- 参数错误、业务逻辑错误 → 不会缓存，避免无意义请求占用空间。