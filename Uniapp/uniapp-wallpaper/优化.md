### 预览轮播图

预览页中

进行壁纸预览时，使用的是一个轮播图组件`swiper`，根据图片列表数组，进行`v-for`循环:

```vue
<swiper circular @change="handleIndexChange" :current="curIndex">
    <swiper-item v-for="item in previewList" :key="item._id">
        <image :src="item.picUrl" mode="aspectFill"></image>
    </swiper-item>
</swiper>
```

列表页使用的是小图`url`，预览页使用的时大图`url`，消耗更大。

页面加载时，会直接根据`image`的`src`值获取图片，加入数组比较大，一旦进入预览页面,会一次性加载很多图片，消耗了比较大的网络带宽。因为用户可能只是点击了某一张图进行预览，但是却加载了所有图片的大图，就浪费了流量，可能会造成用户流失。



#### 解决：

使用`v-if`

```vue
    <swiper circular @change="handleIndexChange" :current="curIndex">
      <swiper-item v-for="(item, index) in previewList" :key="item._id">
        <image
          v-if="index === curIndex"
          :src="item.picUrl"
          mode="aspectFill"
          @click="handleMaskState"></image>
      </swiper-item>
    </swiper>
```

`v-if="index === curIndex"`，只有当前图片的索引值 等于 当前预览的图片索引值时，这张图片才会显示，这样就只会加载当前这一张图片，其它的图片都不会加载了。

只有一个网络请求

![image-20250904100823696](./../../typora-pic/image-20250904100823696.png)



但是会产生另外的问题：

白屏

就是滑动切换图片时，下一站还没有加载，就会有白屏，用户体验不是很好。

![image-20250904100925640](./../../typora-pic/image-20250904100925640.png)

另一个问题就是

切换到上一张已经访问过的图片时，因为`v-if`的原因，还会有白屏，体验不好。



维持一个索引集合，保存当前已经访问过的图片索引，每次访问了一个新的图片时，就把这张图片的索引添加到这个集合中，同时对`image`元素的校验修改为 判断图片索引是否在集合中。

```js
const loadedIndexSet = new Set();

// 当轮播图切换时
const handleIndexChange = (e) => {
  // 最新的索引值
  const newIndex = e.detail.current;
  curIndex.value = newIndex;
  if (!loadedIndexSet.has(curIndex.value)) {
    loadedIndexSet.add(curIndex.value);
  }
};
```



```vue
<image
       v-if="loadedIndexSet.has(index)"
       :src="item.picUrl"
       mode="aspectFill"
       @click="handleMaskState"></image>
```



这样就实现了已经访问的图片，会一直存在，不会再次白屏，但是还可以优化。



#### 预加载

提前加载当前图片的上一张和下一张，为了优化体验

加入当前索引是0，上一张索引是-1，下一张是1，

但是-1肯定不对，-1 % 数组长度就行 = 最后一个索引。



预加载函数

```js
function preLoad() {
  // 加入当前图片索引
  if (!loadedIndexSet.has(curIndex.value)) {
    loadedIndexSet.add(curIndex.value);
  }
  // 加入前一张和后一张图片索引
  let prev =
    (curIndex.value - 1 + previewList.value.length) % previewList.value.length;
  let next = (curIndex.value + 1) % previewList.value.length;
  console.log(prev, curIndex.value, next);
  if (!loadedIndexSet.has(prev)) loadedIndexSet.add(prev);
  if (!loadedIndexSet.has(next)) loadedIndexSet.add(next);
}
```

在每次轮播图切换时，进行预加载

```js
// 当轮播图切换时
const handleIndexChange = (e) => {
  // 最新的索引值
  curIndex.value = e.detail.current;
  preLoad();
};
```

在页面`onLoad()`中首次预加载

```js
onLoad((options) => {
  const picId = options.id;
  // ......
  // 根据当前点击的图片id，确认在数组中的索引index
  curIndex.value = previewList.value.findIndex((item) => {
    return item._id === picId;
  });
  // 获取索引值以后,获取这张图片信息，预加载
  if (curIndex.value !== -1) {
    curImageInfo.value = previewList.value[curIndex.value];
    console.log("curindex", curIndex.value);
    preLoad();
  }
});
```



这样每次就实现预加载，初次会加载三张图：

![image-20250904141531186](./../../typora-pic/image-20250904141531186.png)





// 1. 节流；2. 动画；3. 骨架屏；4. 回调地狱优化 5. 换一批

// 尝试使用其它的svg图标

WAServiceMainContext.js?t=wechat&s=1757035689723&v=3.9.2:1 wx.getSystemInfoSync is deprecated.Please use 

回顾async ,await,

js的取余数

### 回调地狱

在进行用户下载图片时，需要获取权限。

大致的逻辑如下：

保存图片到相册：`uni.saveImageToPhotosAlbum`不支持网络地址，所以使用前，我们要获取图片的本地地址。

通过`uni.getImageInfo`获取图片的本地地址，在`success`回调中使用`uni.saveImageToPhotosAlbum`，

但是保存到相册，用户可能同意授权，也可能不同意授权，这时候需要在`success`回调和`fail`回调中写不同的逻辑，假如用户拒绝授权，需要在`fail`回调中弹出`Modal`告知用户需要获得授权，用户同意之后，还要打开设置让用户手动授权，还需要获取用户的授权结果等等。这样造成了回调地狱。

`原始代码：`

```js
    uni.getImageInfo({
      src: currentInfo.value.picurl,
      success: (res) => {
        uni.saveImageToPhotosAlbum({
          filePath: res.path,
          success: (res) => {
            uni.showToast({
              title: "保存成功，请到相册查看",
              icon: "none",
            });
          },
          fail: (err) => {
            if (err.errMsg == "saveImageToPhotosAlbum:fail cancel") {
              uni.showToast({
                title: "保存失败，请重新点击下载",
                icon: "none",
              });
              return;
            }
            uni.showModal({
              title: "授权提示",
              content: "需要授权保存相册",
              success: (res) => {
                if (res.confirm) {
                  uni.openSetting({
                    success: (setting) => {
                      console.log(setting);
                      if (setting.authSetting["scope.writePhotosAlbum"]) {
                        uni.showToast({
                          title: "获取授权成功",
                          icon: "none",
                        });
                      } else {
                        uni.showToast({
                          title: "获取权限失败",
                          icon: "none",
                        });
                      }
                    },
                  });
                }
              },
            });
          },
          complete: () => {
            uni.hideLoading();
          },
        });
      },
    });
```



通过`promise`逐步封装：

```js
// 获取图片信息
export function getImageInfo(src) {
  return new Promise((resolve, reject) => {
    uni.getImageInfo({
      src,
      success: resolve,
      fail: reject,
    });
  });
```

```js
// 保存图片到相册
export function saveImageToAlbum(filePath) {
  return new Promise((resolve, reject) => {
    uni.saveImageToPhotosAlbum({
      filePath,
      success: resolve,
      fail: reject,
    });
  });
}
```

```js
// 打开设置
export function openSetting() {
  return new Promise((resolve, reject) => {
    uni.openSetting({
      success: resolve,
    });
  });
}
```

```js
// 显示模态窗
export function showModal(options) {
  return new Promise((resolve, reject) => {
    uni.showModal({
      ...options,
      success: resolve,
    });
  });
}
```



封装一个 **通用的 `uniPromisify` 工具函数**

### ✅ 最佳实践建议

- **封装的工具函数**（如 `savePicToAlbum`、`getImageInfo`）最好保持 **纯功能**，只负责数据和状态，不要掺杂 UI。
- **UI 反馈**（如 `uni.showToast`、`uni.showModal`）放在业务逻辑调用层。



功能和 UI 耦合:

附带一个 `toast`，同时承担了 UI 展示的逻辑

```js
function savePicToAlbum(localPath) {
  return new Promise((resolve, reject) => {
    uni.saveImageToPhotosAlbum({
      filePath: localPath,
      success: (res) => {
        uni.showToast({ title: "保存成功，请到相册查看", icon: "none" });
        resolve(res);
      },
      fail: reject,
    });
  });
}
```



较好的封装：

```js
// 保存图片到相册
export function saveImageToAlbum(filePath) {
  return new Promise((resolve, reject) => {
    uni.saveImageToPhotosAlbum({
      filePath,
      success: resolve,
      fail: reject,
    });
  });
}
```



在外部 `.then / await` 成功后执行

```js
async function doSave(localPath) {
  try {
    await saveImageToAlbum(localPath);
    uni.showToast({ title: "保存成功，请到相册查看", icon: "none" });
  } catch (err) {
    uni.showToast({ title: "保存失败", icon: "none" });
  }
}
```

👉 特点：

- `saveImageToAlbum` 只负责「保存」，不负责 UI。
- 业务层可以自由决定 **什么时候、用什么方式提示**。
- 逻辑更清晰、解耦合，函数可复用性更好。



### 开发环境和生产环境



后续学习：

![image-20250908151152561](./../../typora-pic/image-20250908151152561.png)



![image-20250908151141046](./../../typora-pic/image-20250908151141046.png)







