不良地质体遥感影像解译平台

项目简介：基于WebGIS的地质灾害分析平台，集成多种深度学习模型（滑坡、建筑、水体识别），支持用户上传影像并绘制感兴趣区域（AOI），一键调用算法推理并实时渲染解译结果，辅助地质隐患排查。

**主要工作：**

1. 负责项目的架构设计与开发，完成地图渲染、影像加载、图层管理、矢量编辑、解译结果管理等核心模块的开发与优化。
2. 采用Composition API 模式对GIS逻辑进行二次封装；将地图初始化、图层管理、绘制交互、点位系统等逻辑抽象为Composables（useOlMap / useDraw / useLayerManager）等核心Hooks，将地图状态与UI组件完全解耦，提升代码复用率。
3. 交互式矢量编辑模块：基于ol/interaction 开发高自由度的矢量绘制与编辑工具，支持多边形绘制、节点吸附与拓扑修改；设计动态样式配置面板，支持用户对识别结果（如水体、建筑）进行填充色、边框、透明度的实时自定义渲染。
4. ~~基于自身深度学习背景，参与模型输入输出格式设计，明确影像裁剪范围、坐标表达、推理结果结构，减少前后端与算法团队的沟通成本，实现从影像上传到推理结果可视化的完整自动化流程。~~
5. 结合自身深度学习背景，主导制定前端与算法模型的数据交互规范；设计通用的推理任务调度流程（AOI 选取 -> 模型动态选择 -> 异步轮询结果），有效解决了大模型推理耗时导致的前端响应超时问题，确保用户体验流畅。



##### AOI是什么，怎么工作的

用户可以在地图上绘制范围……然后把用户的范围发送到后端。
这就叫 **AOI**。



- **场景描述：**
  “因为遥感影像数据量非常大，全图识别效率太低。我们支持用户通过 OpenLayers 的绘图工具（Draw Interaction），手动框选一个多边形，这个区域就是 AOI。”
- **技术实现：**
  1. **前端绘制：** 使用 ol/interaction/Draw 绘制矢量图形。
  2. **数据转换：** 将用户画的这个图形的坐标，转化为 **GeoJSON** 格式（或者 WKT 格式）。
  3. **发送请求：** 把这个 GeoJSON 发给后端算法接口。
  4. **后端处理：** 后端根据这个 GeoJSON 对原始大图进行**裁剪（Clip）**，只把裁剪下来的一小块图片喂给 AI 模型。（是不是裁剪我也不知道）
  5. **结果返回：** AI 识别完，返回结果，前端再叠加上去。



问： 用户上传的地图影响图片很大怎么办？前端怎么处理？

答（思路）： 可以说限制大小，或者提到 ImageStatic 加载时的性能优化，或者配合后端切片（如果有做的话）。

问： AI 识别回来的数据量很大（比如几万个多边形），地图卡顿怎么解决？

答（思路）： 如果你没做优化，可以说“目前数据量还行”，如果做了，可以说“使用了 WebGL 渲染模式”或者“简化了 GeoJSON 的精度”。



##### 前端提交任务以后，如何知道当前任务的处理状态的

通过短轮询 (Short Polling)方式

**核心逻辑：**

1. **提交任务：** 前端把 AOI（坐标范围）发给后端。
2. **立即响应：** 后端**不等待** AI 跑完，而是立刻返回一个 `task_id`（任务ID），告诉前端：“收到，我去跑了”。
3. **周期查询：** 前端拿到 `task_id` 后，每隔一段时间（比如 2秒 或 5秒）用这个 ID 去问后端：“跑完了吗？”
4. **获取结果：**
   - 后端回复：“处理中（Pending）” -> 前端继续等，继续问。
   - 后端回复：“成功（Success）” + 数据 -> 前端停止询问，渲染地图。
   - 后端回复：“失败（Failed）” -> 前端停止询问，报错。

 



```js
// 伪代码示例
const startAnalysis = async () => {
  // 1. 提交任务
  const { taskId } = await api.submitAnalysis({ aoi: myAoiGeoJson });
  
  // 开启轮询
  pollStatus(taskId);
};

const pollStatus = async (taskId) => {
  // 2. 定时器
  const interval = setInterval(async () => {
    const res = await api.checkStatus(taskId);
    
    // 3. 判断状态
    if (res.status === 'COMPLETED') {
      clearInterval(interval); // 停止轮询
      renderResult(res.data);  // 渲染结果
      ElMessage.success('识别完成！');
    } else if (res.status === 'FAILED') {
      clearInterval(interval);
      ElMessage.error('识别失败');
    }
    // 如果是 PROCESSING，什么都不做，等下一次循环
  }, 3000); // 每3秒问一次
};
```

**面试话术（加分项）：**

“考虑到 AI 模型推理耗时可能在几秒到几分钟不定，直接等待 HTTP 响应会导致超时。我采用了**异步任务 + 轮询**的机制。用户提交 AOI 后，后端返回 TaskID，前端通过 setInterval 或递归 setTimeout 每隔 3 秒查询一次任务状态，直到状态变为 Completed，再拉取结果渲染。同时也设计了**超时熔断机制**，如果超过 5 分钟未完成，自动停止轮询并提示用户。”



**如果面试官问细节，你要补充两点 UX（用户体验）上的优化：**

1. **Loading 状态：** “在轮询期间，我在地图上该区域显示一个‘分析中’的 Loading 遮罩或骨架屏，防止用户重复点击。”
2. **取消机制：** “如果用户等不及了，我提供一个‘取消’按钮，点击后前端停止轮询，并发送请求告诉后端‘别跑了，用户不要了’，节省服务器资源。”

这样回答，你就完美闭环了：**技术实现（轮询）+ 业务逻辑（TaskID）+ 用户体验（Loading/取消）**。



##### setInterval 和setTimeout 的区别





##### 问： 你的 Hooks 是怎么封装的？

答（思路）： 准备好说：我把 Map 对象放在一个全局的 Store 或者 shallowRef里，然后 Hooks 接受这个 Map 对象作为参数，返回具体的 addLayer, removeLayer 方法...