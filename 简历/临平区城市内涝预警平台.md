临平区城市内涝预警平台（大屏 + 后台管理）

项目简介：集城市隧道水位监测、预警可视化与后台管理于一体的防汛监测平台。通过数字孪生技术映射临平区下沉隧道与避难所分布，实现水位预警响应与可视化指挥。

主要工作：

1. 基于CustomDataSource API设计分层管理架构，将下沉隧道、摄像头、避难所等不同业务实体进行分组隔离，实现了多图层的独立显隐控制与批量操作，解决了传统Entity混杂导致的管理混乱与渲染性能瓶颈。
2. 针对高频水位数据推送场景，设计 Diff差量更新策略，实时比对新旧数据状态，仅更新变化点位，替代全量重绘方案，优化地图渲染性能。（利用 Map数据结构建立点位ID索引）
3. 基于 Composition API 重构 GIS模块，抽离测量与交互逻辑为独立Hooks，通过数据驱动DOM弹窗，实现了视图层与逻辑层的彻底分离，显著降低组件耦合度并提升可维护性。
4. 结合动态组件（Dynamic Components）与策略模式，实现了不同实体类型（如隧道、监测点、气象站等）自动匹配不同弹窗组件的机制，新增实体类型无需修改核心交互逻辑。
5. 后台管理与可视化：负责后台系统搭建，实现基于 RBAC的权限管理与动态路由注册，完成点位数据的CRUD模块；集成 ECharts 开发多维度防汛仪表盘，实现水位趋势与报警统计的动态可视化展示。





面试预判（必问的技术点）

##### 问：为什么要用 CustomDataSource 而不是直接 viewer.entities.add？

答： 为了更好的管理和性能。我有三种点位（隧道、摄像头、避难所），如果全混在 viewer.entities 里，我想“只隐藏摄像头”就需要遍历所有点判断类型，效率低。用 CustomDataSource 我可以创建三个 dataSource，分别管理，隐藏只需一行代码 cameraSource.show = false。



Cesium 并不是没有图层概念，而是它的“图层”逻辑与 OpenLayers (OL) 这种纯二维地图引擎有很大的不同。

在OL中，不同类型的数据可以放在不同的图层上，

cesium中使用CustomDataSource模拟图层这种概念，相当于一个集合，把同类型的放在一个集合中，然后直接把整个集合添加到Viewer 上。可以直接控制这个集合的显示与隐藏。



虽然 CustomDataSource 使用起来最像 OpenLayers 的逻辑（因为它管理的是 Entity，API 很友好），但它有一个**性能瓶颈**。如果你要在图层上放 **几万个点**，Entity 机制会非常卡。

这时候，你需要用更底层的 **PrimitiveCollection** 来充当“图层”。

- **CustomDataSource (Entity方式):** 适合数据量少（几千个以内），交互要求高（自带点击事件），API 简单。
- **PrimitiveCollection (Primitive方式):** 适合数据量巨大（几十万个），性能极高，但代码难写。



1. **首选方案 (CustomDataSource)**：
   如果你处理的是常规业务数据（点位、图标、简单的线面，数量在几千个以内），直接使用 CustomDataSource。
   - **优点**：完全符合你对 OpenLayers 图层的认知，支持 show 属性，支持 Promise 加载机制，支持 Entity API。
2. **大数据方案 (PrimitiveCollection)**：
   如果你需要渲染海量数据（比如十万辆出租车轨迹），请创建一个 PrimitiveCollection 对象作为图层容器。
3. **注意 3D 遮挡**：
   再次提醒，OpenLayers 中你可以通过 setZIndex 让下一层覆盖上一层。但在 Cesium 的 CustomDataSource 中，**没有 Z-Index**。
   如果“医院层”的点和“道路层”的线在同一个三维坐标上，谁盖住谁取决于深度检测（Depth Test）或者是随机的 Z-fighting（闪烁），而不是取决于你 add 的顺序。如果需要避免重叠，必须给其中一个数据增加 **高度 (Height)**





 

##### 问：你的 Diff 更新具体怎么做的？

答： 我维护了一个 Map<Id, Entity> 的字典。后端每秒推一次数据，我遍历新数据，用 ID 去 Map 里找对应的 Entity。如果找到了且状态变了（比如水位从正常变警戒），我就只修改这个 Entity 的 image 或 color。如果 Map 里没有，说明是新增点位，我再 add。这样避免了频繁的创建和销毁对象。

 

##### 问：Popup 弹窗怎么实现跟随地球移动的？

弹窗是否跟随地球移动，就是看需求，假如是在每一个点位位置弹出弹窗，就是用经纬度坐标，使用overlay

但是每次弹窗位置变化

所以我直接使用了css控制，让弹窗始终显示在地图的

答： 我使用了 Cesium 的 Scene.postRender 事件监听，每一帧渲染结束后，通过 SceneTransforms.wgs84ToWindowCoordinates 把点位的 3D 坐标转成屏幕的 2D 坐标，然后赋值给弹窗 DOM 的 top 和 left 样式。



##### Hooks

比如地图的初始化

地图封装为一个组件，初始化地图的逻辑封装为hooks，在地图组件中调用这个hooks，完成初始化，然后发送完成事件

业务组件中，使用地图组件，监听到完成事件以后，做其它的操作。

比如交互

点击某些点位，弹出一个对话框，不同类型的点位，弹出的对话框可能不同。

这些对话框可以封装为一个单独的组件，也可以直接在业务组件中的模板中写出来



点击，然后弹出对话框，对话框需要控制他的是否显示，需要关闭对话框，内部也需要数据。

那么，我们有一个hooks，`useInteraction`交互相关的。

这个hooks中，定义一些响应式对象`overlayState`，管理弹窗是否显示，弹窗的定位位置top,left,弹窗的数据

在点击事件中，我们就给这个响应式对象`overlayState`赋值/ 更新，然后hooks返回这个响应式对象

在业务组件中，通过使用hooks，可以获取到响应式对象`overlayState`，然后利用它控制弹窗组件。

这种组合方式，数据驱动DOM弹窗，视图层与逻辑层的分离，逻辑清晰，方便维护，而且复用性强。