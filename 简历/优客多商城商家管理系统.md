### 优客多商城商家管理系统

项目简介：为商家提供商品、物流、仓储、店铺、客服等一体化管理后台，提高运营效率。

主要工作：

**1.** 针对多规格商品发布场景，设计并实现基于笛卡尔积算法的SKU动态表格生成器。支持颜色/尺寸/材质等多维规格的自由组合，自动计算并渲染N*M行数据。

**2.** 基于v-model双向绑定机制，二次封装el-upload、el-cascader、wangeditor，实现了单/多图/pdf上传与回显、省市区数据异步懒加载及富文本编辑器组件。

**3.** 构建基于RBAC模型的动态权限系统。结合后端返回的权限树，实现路由动态注册与递归组件渲染无限层级侧边栏，并实现单一子节点自动提升，简化菜单层级，提升用户操作效率。

**4.** 从0到1搭建项目架构，配置 ESLint + Prettier + Husky + Commitlint 工作流，统一团队代码风格与提交规范；二次封装Axios，实现请求拦截、全局错误处理与Token无感刷新机制，增强系统健壮性。



#### 问题：

##### 路由动态注册是怎么做的

目的：做动态路由主要是为了落实 **RBAC 权限模型**。

第一是**安全性**，确保用户只能访问其职责范围内的页面，对于无权访问的路径，前端路由表中根本就不存在，直接拦截在404，比单纯的路由守卫拦截更彻底。

第二是**维护效率**，实现了菜单与路由的统一管理。前端根据后端返回的权限树动态生成路由表，避免了还要手动维护一份静态路由清单，也减少了因前后端权限数据不一致导致的Bug。



做法：

主要是借助路由拦截器`router.beforeEach`，

用户打开网站时，会从根路径 `/` 重定向到首页 `/dashboard` ，这时候有可能是第一次访问，那肯定是没有登录，也有可能是之前登录过。总之，这里会触发拦截器，检查用户有没有登录，如果没有登录，检查访问的页面是不是白名单，决定要不要放行。

假如没有登录，token获取不到，去的也不是白名单，则跳转到登录页尝试登录。

用户登录，调用登录接口，再获取用户信息以及路由信息，路由是一个嵌套结构的数据。这时候在进行跳转，就是访问之前没进去的页面（这里有一个`parseRedirect`），这时候再次触发了路由拦截。

这时候就是登录了，但是动态路由注册没完成。这里会做一个检查，检查是否完成了路由注册，完成了的话，就直接放行`next()`,不会再触发路由拦截。

没有完成路由注册的话，就进行路由注册。

后端返回的路由数据中有每一条路由的`path`以及对应的组件路径`component`，前端需要按照组件路径`component`的层级建立每一个组件，基本上就是要保持路径匹配

​		使用`import.meta.glob('@/views/**/**.vue')`，是基于文件路径的动态导入，返回结果是一个对象，其中`key`是文件的路径，`value`是一个懒加载函数。

Webpack 中对应的是 require.context

```js
{
  '/src/views/home/index.vue': () => import('/src/views/home/index.vue'),
  '/src/views/system/user.vue': () => import('/src/views/system/user.vue')
}
```

这样就有了一个`路径 -> 组件`映射表

因为后端返回的是组件路径字符串`component：product-manage/on-sale/index`

通过字符串去这个映射对象里匹配，从而实现组件的动态加载。

只要匹配到了，就设置`component`为对应的懒加载函数，最后再统一使用`addRoute`进行路由注册。

其中

- `import.meta`：这是 ES 模块的标准属性，包含当前模块的元数据。
- `.glob(...)`：Vite 特有的方法（Webpack 中对应的是 require.context）。
- `@/views/**/**.vue`：这是匹配规则（Glob Pattern）。
  - `@`：通常配置为 src 目录的别名。
  - `views`：文件夹名。
  - `**`：表示递归匹配（不管是 views/a.vue 还是 views/a/b/c.vue 都能找到）。
  - `*.vue`：只匹配后缀为 .vue 的文件。



##### 递归组件渲染无限层级侧边栏，以及单一子节点自动提升是怎么做的

侧边栏生成需要使用所有的路由

单一子节点自动提升，这个需要产品确定，到底是要不要提升。

所谓提升就是，比如一个一级菜单下面只有一个子菜单项，那就没有必要显示这个一级菜单，直接显示子菜单项就行了。如果是多个子菜单项，那就正常按照一级菜单，然后子菜单项显示。

首先路由是嵌套结构的，`children`数组是下级路由

递归组件`SidebarMenuItem.vue`，传递给组件的是一个路由对象，他可能是一个含有children的父级路由，也可能是一个底层的叶子路由。也可能是只含有一个叶子路由的父路由

所以这个组件内部，需要做判断。

假如说是只有一个可显示的子节点，则直接显示子节点。那就使用`el-menu-item`

其中`hasOneShowingChild`可以判断是否是 `只有一个可显示的子节点的路由` 或者 `是一个叶子节点路由`；

不论是有一个子路由的父路由，还是单独的一个叶子路由，都是直接显示的，逻辑相同。直接使用变量`onlyOneChild`保存需要显示的那条路由，模板中会使用这个变量

`hasOneShowingChild`接收一个路由对象，判断这个路由对象`route.children`，

如果`children`为空，说明叶子路由，直接显示，保存到`onlyOneChild`

如果数组不为空，`filter`过滤，筛选出需要显示的子路由数组，然后再确定数组长度是否为1，为1，说明只有一个可显示的子节点，保存到`onlyOneChild`中



假如是多个子节点的路由，那就使用`el-sub-menu`，使用`#title`插槽可以设置父级菜单的图标以及文本；然后遍历这个路由的`children`数组，数组内又是一个路由对象，这就可以继续使用递归组件`SidebarMenuItem.vue`



##### v-model在dom和组件上使用的区别

在普通`dom`上使用时，比如`input`元素，实际上就是一个语法糖。就是`v-bind`和`@input`的组合。

把变量通过`v-bind`绑定到`value`属性，实现了数据更新时，视图也更新

然后监听`input`事件，把文本框的值重新赋值给变量，实现了视图更新，数据也更新。

在组件上使用时v-model，就需要在组件内部定义`modelValue`，也可以叫其它名字，但是使用v-model时就要写出来。还要定义`update:modelValue`事件。

再通过计算属性的get和set，get来自prop.modelValue值，set时触发update:modelValue

这么做的原因是因为组件内可能需要修改modelValue，而使用一个中间变量来中转，因为单向数据流，不要直接修改prop。

在 Vue 3.4 开始，推荐的实现方式是使用 [`defineModel()`](https://cn.vuejs.org/api/sfc-script-setup.html#definemodel) 宏，这个底层原理就是上面说。

defineModel简化了上面的这个过程，他返回一个ref变量

- 它的 `.value` 和父组件的 `v-model` 的值同步；
- 当它被子组件变更了，会触发父组件绑定的值一起更新。

相当于省去了计算属性的那些步骤



##### 单图/多图/pdf组件的封装思路



##### Axios取消请求

主要场景可能是提交按钮连续多次点击，或者是tab之间的切换，快速点击多个tab,但是数据只显示一份。

当然提交按钮连续多次点击也可以用节流控制。

取消请求的思路就是，用一个映射表



##### 双token与无感刷新

一个叫做access token，一个叫做refresh token，其中access token有效期比较短，可能几十分钟到几个小时

refresh token有效期就比较长了，通常是几天或者一周。

网络请求的拦截器中使用的是access token，如果过期了，后端会返回对应的状态码，我们在响应拦截器中做对应的处理。

处理的逻辑就是，调用获取access token的接口，这个需要使用refresh token获取新的access token，通常也会返回新的refresh token，然后前端更新两个token，然后重新发送请求。

这里有个问题就是，同时有几个请求都是用了过期的token请求，他们就有可能都会进入到拦截器中，获取新的token。这样就生成了多个token，这是没有必要的。

解决方法就是用一个队列保存失败的请求，然后用一个变量控制是否正在进行 刷新token，如果正在刷新，其它的请求不会继续刷新token，只有第一个可以正常继续刷新token。

然后等到第一个请求 完成了刷新token，就清空队列，发送之前的请求。

至于refresh token过期，就直接清除数据，跳转到登陆页面，重新登录。



##### sku表格生成

- **SPU（产品）**：指**一款**商品。
  - *例子：iPhone 15*。这是一个 SPU，它代表这一类手机的集合。
- **SKU（单品）**：指**具体**的那个商品。
  - *例子：iPhone 15 - 黑色 - 128G*。这是一个 SKU，它是你实际发货的那个实体。

**关系：** 一个SPU通常包含多个SKU。



项目中最麻烦的一点

发布商品时，一件商品会有多种规格，比如一件衣服，有颜色和尺码，颜色和尺码可以组合，组合形成的多个sku



先说这个发布商品。

逻辑：

用户输入规格名称，以及对应的规格值，规格值可以输入多个，这样算一组规格。

可以继续添加下一组规格，也可以删除一组规格。

每次添加一组规格以后，要生成对应的sku表格，这个表格有对应的规格列。

比如输入的规格是尺码，表格中就有一个尺码列，输入的规格是尺码和颜色，表格中就有尺码和颜色列。

如果删除某一个规格或者修改某一个规格值，也需要更新这个表格。



用一个数组 `custom_spec_list`保存所有的规格，每一个规格是一个对象结构，`name`，`value`对应规格名称与值数组

```js
    {
      name: '',
      isFixed: false, // 输入完规格名称以后,不可以修改,只能删除以后再新建
      value: [],
      tempValue: '',
      // 是否正在添加规格值，即决定是否显示输入框
      isShowAddInput: false
    }
```

添加新规格规格就是给这个数组添加一个对象

添加规格的值，就是给规格对象的`value`数组添加一个值，每次添加一个规格值，要进行一次更新表格



更新表格，更新表格列，以及sku数据

因为表格中需要显示规格列，列又来自用户输入，所以列需要动态生成，用一个`ref`保存，模板中遍历这个列数组

生成sku数据时需要用一个map，把sku拼接成字符串作为map的key，值就是这一个sku的数组，每次更新时要检查是否存在相同的sku，存在的话就可以直接获取之前的数据。



笛卡尔积生成方式：

颜色 ： 红色、蓝色；尺码： S、M

递归：

函数`fn`，参数是一个二维数组

比如

参数是这种结构的

```ts
[['红色', '蓝色'], ['S', 'M']]
```

目标是生成下面结构：

```ts
[
    ["红色", "S"],
    ["红色","M"],
    ["蓝色","S"],
    ["蓝色","M"]
]
```



reduce：

**`reduce()`** 方法对数组中的每个元素按序执行一个提供的 **reducer** 函数，每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。

参数是一个函数和一个初始值



```js
const data = [['红色', '蓝色'], ['S', 'M']];

const result = data.reduce((acc, curr) => {
    const res = [];
    // 遍历已生成的组合 (acc)
    acc.forEach(prev => {
        // 遍历当前维度的选项 (curr)
        curr.forEach(next => {
            // 将当前选项拼接到之前的组合上
            res.push(prev.concat(next)); 
        });
    });
    return res;
}, [[]]); // 初始化为一个包含空数组的数组

console.log(result);
// 输出:
// [ [ '红色', 'S' ], [ '红色', 'M' ], [ '蓝色', 'S' ], [ '蓝色', 'M' ] ]
```



```ts
1：acc = [[]]; prev = []; 
	curr = ['红色', '蓝色']; 
		next = '红色'; 
			res.push([].concat('红色')) => res.push(['红色'])  res = [['红色']]
		next = '蓝色';
			res.push([].concat('蓝色')) => res.push(['蓝色'])  res = [['红色'],['蓝色']]

2： acc = [['红色'],['蓝色']]; curr = ['S', 'M']
	res  = []
	acc = [['红色'],['蓝色']];
		prev = ['红色']
		cuur =  ['S', 'M']
			next = 'S'
				res.push(['红色'].concat('S')) => res.push(['红色','S'])  
				res = [['红色','S']]
			next = 'M'
				res.push(['红色'].concat('M')) => res.push(['红色','M'])  
				res = [['红色','S'],['红色','M']]
		prev = ['蓝色']
		cuur =  ['S', 'M']
			next = 'S'
            res.push(['蓝色'].concat('S')) => res.push(['蓝色','S'])  
            res = [['红色','S'],['红色','M'],['蓝色','S']]
			next = 'M'
            res.push(['蓝色'].concat('M')) => res.push(['蓝色','M'])  
            res = [['红色','S'],['红色','M'],['蓝色','S'],['蓝色','M']]
	
```



至于回显，因为整体是一个组件，比如编辑一个商品时，把id传递过来，然后请求接口，获取这条id的数据，

然后填充表单数据，这时候就会回填一些数据，然后生成表格，由于数据响应式，表格内容也被填充了。

