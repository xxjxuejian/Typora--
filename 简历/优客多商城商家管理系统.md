### 优客多商城商家管理系统

项目简介：为商家提供商品、物流、仓储、店铺、客服等一体化管理后台，提高运营效率。

主要工作：

**1.** 针对多规格商品发布场景，设计并实现基于笛卡尔积算法的SKU动态表格生成器。支持颜色/尺寸/材质等多维规格的自由组合，自动计算并渲染N*M行数据。

**2.** 基于v-model双向绑定机制，二次封装el-upload、el-cascader、wangeditor，实现了单/多图/pdf上传与回显、省市区数据异步懒加载及富文本编辑器组件。

**3.** 构建基于RBAC模型的动态权限系统。结合后端返回的权限树，实现路由动态注册与递归组件渲染无限层级侧边栏，并实现单一子节点自动提升，简化菜单层级，提升用户操作效率。

**4.** 从0到1搭建项目架构，配置 ESLint + Prettier + Husky + Commitlint 工作流，统一团队代码风格与提交规范；二次封装Axios，实现请求拦截、全局错误处理与Token无感刷新机制，增强系统健壮性。



#### 问题：

##### 路由动态注册是怎么做的

目的：做动态路由主要是为了落实 **RBAC 权限模型**。

第一是**安全性**，确保用户只能访问其职责范围内的页面，对于无权访问的路径，前端路由表中根本就不存在，直接拦截在404，比单纯的路由守卫拦截更彻底。

第二是**维护效率**，实现了菜单与路由的统一管理。前端根据后端返回的权限树动态生成路由表，避免了还要手动维护一份静态路由清单，也减少了因前后端权限数据不一致导致的Bug。



做法：

主要是借助路由拦截器`router.beforeEach`，

用户打开网站时，会从根路径 `/` 重定向到首页 `/dashboard` ，这时候有可能是第一次访问，那肯定是没有登录，也有可能是之前登录过。总之，这里会触发拦截器，检查用户有没有登录，如果没有登录，检查访问的页面是不是白名单，决定要不要放行。

假如没有登录，token获取不到，去的也不是白名单，则跳转到登录页尝试登录。

用户登录，调用登录接口，再获取用户信息以及路由信息，路由是一个嵌套结构的数据。这时候在进行跳转，就是访问之前没进去的页面（这里有一个`parseRedirect`），这时候再次触发了路由拦截。

这时候就是登录了，但是动态路由注册没完成。这里会做一个检查，检查是否完成了路由注册，完成了的话，就直接放行`next()`,不会再触发路由拦截。

没有完成路由注册的话，就进行路由注册。

后端返回的路由数据中有每一条路由的`path`以及对应的组件路径`component`，前端需要按照组件路径`component`的层级建立每一个组件，基本上就是要保持路径匹配

​		使用`import.meta.glob('@/views/**/**.vue')`，是基于文件路径的动态导入，返回结果是一个对象，其中`key`是文件的路径，`value`是一个懒加载函数。

Webpack 中对应的是 require.context

```js
{
  '/src/views/home/index.vue': () => import('/src/views/home/index.vue'),
  '/src/views/system/user.vue': () => import('/src/views/system/user.vue')
}
```

这样就有了一个`路径 -> 组件`映射表

因为后端返回的是组件路径字符串`component：product-manage/on-sale/index`

通过字符串去这个映射对象里匹配，从而实现组件的动态加载。

只要匹配到了，就设置`component`为对应的懒加载函数，最后再统一使用`addRoute`进行路由注册。

其中

- `import.meta`：这是 ES 模块的标准属性，包含当前模块的元数据。
- `.glob(...)`：Vite 特有的方法（Webpack 中对应的是 require.context）。
- `@/views/**/**.vue`：这是匹配规则（Glob Pattern）。
  - `@`：通常配置为 src 目录的别名。
  - `views`：文件夹名。
  - `**`：表示递归匹配（不管是 views/a.vue 还是 views/a/b/c.vue 都能找到）。
  - `*.vue`：只匹配后缀为 .vue 的文件。



##### 递归组件渲染无限层级侧边栏，以及单一子节点自动提升是怎么做的

侧边栏生成需要使用所有的路由

单一子节点自动提升，这个需要产品确定，到底是要不要提升。

所谓提升就是，比如一个一级菜单下面只有一个子菜单项，那就没有必要显示这个一级菜单，直接显示子菜单项就行了。如果是多个子菜单项，那就正常按照一级菜单，然后子菜单项显示。

首先路由是嵌套结构的，`children`数组是下级路由

递归组件`SidebarMenuItem.vue`，传递给组件的是一个路由对象，他可能是一个含有children的父级路由，也可能是一个底层的叶子路由。也可能是只含有一个叶子路由的父路由

所以这个组件内部，需要做判断。

假如说是只有一个可显示的子节点，则直接显示子节点。那就使用`el-menu-item`

其中`hasOneShowingChild`可以判断是否是 `只有一个可显示的子节点的路由` 或者 `是一个叶子节点路由`；

不论是有一个子路由的父路由，还是单独的一个叶子路由，都是直接显示的，逻辑相同。直接使用变量`onlyOneChild`保存需要显示的那条路由，模板中会使用这个变量

`hasOneShowingChild`接收一个路由对象，判断这个路由对象`route.children`，

如果`children`为空，说明叶子路由，直接显示，保存到`onlyOneChild`

如果数组不为空，`filter`过滤，筛选出需要显示的子路由数组，然后再确定数组长度是否为1，为1，说明只有一个可显示的子节点，保存到`onlyOneChild`中



假如是多个子节点的路由，那就使用`el-sub-menu`，使用`#title`插槽可以设置父级菜单的图标以及文本；然后遍历这个路由的`children`数组，数组内又是一个路由对象，这就可以继续使用递归组件`SidebarMenuItem.vue`



##### v-model在dom和组件上使用的区别

在普通`dom`上使用时，比如`input`元素，实际上就是一个语法糖。就是`v-bind`和`@input`的组合。

把变量通过`v-bind`绑定到`value`属性，实现了数据更新时，视图也更新

然后监听`input`事件，把文本框的值重新赋值给变量，实现了视图更新，数据也更新。

在组件上使用时v-model，就需要在组件内部定义`modelValue`，也可以叫其它名字，但是使用v-model时就要写出来。还要定义`update:modelValue`事件。

再通过计算属性的get和set，get来自prop.modelValue值，set时触发update:modelValue

这么做的原因是因为组件内可能需要修改modelValue，而使用一个中间变量来中转，因为单向数据流，不要直接修改prop。

在 Vue 3.4 开始，推荐的实现方式是使用 [`defineModel()`](https://cn.vuejs.org/api/sfc-script-setup.html#definemodel) 宏，这个底层原理就是上面说。

defineModel简化了上面的这个过程，他返回一个ref变量

- 它的 `.value` 和父组件的 `v-model` 的值同步；
- 当它被子组件变更了，会触发父组件绑定的值一起更新。

相当于省去了计算属性的那些步骤



##### 单图/多图/pdf组件的封装思路



Axios取消请求了解吗

token，jwt

双token与无感刷新