## React 使用 CSS 样式

在 React 应用程序中使用 CSS 有多种方法。

以下是一些常见的方式以及如何在 React 中实现这些方法的详细说明。



### 🌈 1. **内联样式（inline style）**

例如：

```tsx
<div style={{ color: 'red', fontSize: 20 }}></div>
```

#### ✅ 优点

- **简单粗暴、立即生效**：不用文件、不用命名，想到就写。
- **样式完全局部，不会污染全局**：你改它不会影响别人。
- **动态样式很好写**：因为是 JS 对象，用变量、state 调整很顺手。

#### ❌ 缺点

- **不能写伪类（:hover / :before）**：这点直接把内联样式“判死刑”。
- **不能写媒体查询**：响应式没法玩。
- **样式表达能力低**：动画、复杂选择器统统不行。
- **写多了组件巨大无比、难阅读**

👉 结论：**适合非常小的小样式，不适合作为主要方案。**

------



### 🎨 2. **样式文件（普通 CSS / SCSS / Less 文件）**

例如：

```scss
/* App.scss */
.title {
  color: red;
}
```

在组件里：

```js
import './App.scss'
```

#### ✅ 优点

- **表达能力最强**：嵌套、伪类、动画、媒体查询全都能写。
- **文件结构清晰**：样式文件就是样式，不会跟 JSX 混着。
- **SCSS/Less 有变量、mixin**：可维护性高。
- **适合大型项目的全局样式体系**

#### ❌ 缺点

- **全局污染问题**：类名如果不规范，很容易互相覆盖。
- **需要自己管理命名（例如 BEM）**：长痛 OR 短痛，命名永恒的战争 🫠
- **多人协作可能导致样式失控**

👉 结论：**适合需要大量样式、复杂布局、主题系统的地方，但要搭配命名规范或 Modules 才舒服。**

------



### 📦 3. **CSS Modules（xxx.module.css/scss/less）**

在 React 中长这样：

```tsx
import styles from './Button.module.scss'
<div className={styles.btn}></div>
```

#### ✅ 优点

- **样式自动局部化，不会冲突** → 这是它最大优势
   每个类名都会被 hash，例如：`.btn → .btn_f3jk1`
- **不用纠结命名冲突，非常省心**
- **仍然支持所有 CSS/SCSS/Less 特性**
   嵌套、变量、伪类、媒体查询都能用。
- **理想的组件级样式解决方案**

#### ❌ 缺点

- **无法写全局样式**（可以写 global，但那就违背本意了）
- **在大型页面上，会有太多 module 文件**
- **类名需要通过 JS 引用，不如直接写字符串直观**
- **跟第三方组件库混用时可能需要覆盖复杂**

👉 结论：**非常适合组件化体系，但不适合作为全局样式方案。**



## CSS-in-JS 

Styled Components / Emotion 并不是“不能用”，而是：

> **它们的黄金时代（2018–2021）确实过去了，现在已经不是默认推荐方案。**

但是！
 它们依然在一些场景下表现很好，只是已经不是“谁都用”的那种主流选择了。

------

### 🥶 **为什么大家开始不用 CSS-in-JS 了？（核心原因）**

#### ① **运行时性能开销太重**

Styled Components / Emotion 是 *运行时生成样式* 的。

也就是说：

- 组件渲染时执行 JS
- 动态插入 `<style>` 标签
- 还要 hash 类名
- 再做样式去重

这在 SSR / CSR 混合的环境里变成负担，影响：

- 初次渲染速度
- 大量组件渲染性能
- 低端设备体验

> 简单说：**太费劲了，不划算。**

------

#### ② **SSR 场景很痛苦（Next.js 时代的硬伤）**

Next.js 13 / React 服务器组件（RSC）出现后：

- CSS-in-JS 和 RSC 天然不合适
- 你要做 SSR，就必须 patch 各种兼容问题
- 以及必须处理“样式闪烁”“重复渲染”等问题

Next.js 文档都明确暗示：**请用 CSS 文件 or Tailwind**
 （他们不是直接说“别用 CSS-in-JS”，但意思你懂的 😅）

------

#### ③ **构建工具进化了（Vite、ESBuild、SWC）**

现在构建工具越来越倾向：

- 预构建
- 静态提取
- 0 运行时

而 CSS-in-JS 刚好走反方向。

Tailwind、CSS Modules、SCSS 这种静态方案更轻、更快、更可优化。

------

### 🪄 那现在还有哪里会用 CSS-in-JS？（不是没人用，只是更挑场景了）

#### ⭐ 还适合的场景

- **设计系统 / UI 组件库（需要强动态主题）**
- **需要完全 JS 控制样式（例如动画、主题切换、可配置化组件）**
- **React Native（没这玩意写不了）**

像 Material UI（MUI）现在还用 Emotion（不过他们也在弱化它）。

#### 😵 不太适合的场景

- SSR (Next.js 13+)
- 追求最佳性能的中大型 Web 项目
- 移动端 H5（弱机型卡得要命）
- 后台管理系统（不需要那么多动态主题）

------



## 🌟 那现在推荐什么？

**大部分团队已经迁移到：**

> **Tailwind + SCSS/Modules（最主流）**
>  或
>  **CSS Modules + SCSS（保守但稳定）**

这两套都比 CSS-in-JS 更快、更稳定、维护成本更低。

------



## 🎁 最关键的一句话总结

> **CSS-in-JS 没“死”，但已经不是主角。**
>  现在它更像“只在特定需求里登场的高手”，
>  而不是所有项目都要请来的“大师”。



## 🥇 **推荐的 2 套黄金方案**

### **方案 A（主流）：Tailwind（主） + SCSS（辅） + 少量 CSS Modules**

适合：

- 所有中小项目
- 后台管理系统
- SPA
- Vite / React 18 项目

理由：

- 好写
- 快
- 可维护
- 团队成本低
- 未来五年不会过时

------

### **方案 B（SSR 项目）：Tailwind + CSS Modules**

适合：

- Next.js 13+
- 服务端渲染
- 访问量大、性能要求高的项目

理由：

- 官方最推荐
- 没有任何运行时
- 性能最好

------

### 📝 **附：每种方案该用在项目的哪些部分？**

| 部分                   | 推荐方案               | 理由                           |
| ---------------------- | ---------------------- | ------------------------------ |
| 布局（Flex/Grid）      | Tailwind               | 写得快，不出错                 |
| spacing/padding/margin | Tailwind               | 统⼀体系                       |
| 全局样式               | SCSS                   | 变量、mixin、reset、全局 theme |
| 表单组件样式           | CSS Modules + SCSS     | 精细控制 + 不污染              |
| 动画/复杂选择器        | SCSS                   | 表达力强                       |
| 第三方库覆盖样式       | SCSS                   | Tailwind 不适合做这件事        |
| 动态样式（依赖 state） | inline style（超少量） | 方便，没有多写文件的必要       |

### 🎉 总结：

> **Tailwind 负责 80% 的重复样式**
>  **CSS Modules 负责组件隔离**
>  **SCSS 负责复杂逻辑、主题、全局体系**
>
> → 这三者搭起来，就是 2025 最稳、最舒服、最好维护的 React 样式体系。