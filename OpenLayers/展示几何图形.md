###  OpenLayers 里展示几何图形的标准步骤

#### 1. 后端返回Geometry的坐标

**1. 创建几何对象（Geometry）**

- `new Point([x, y])`
- `new LineString([[x1, y1], [x2, y2], ...])`
- `new Polygon([[[x1, y1], [x2, y2], ..., [x1, y1]]])`

> 注意：坐标通常要先通过 `fromLonLat` 转换成 Web Mercator。

**2. 创建要素（Feature）**

- `new Feature({ geometry: geometryObj })`

**3. 创建数据源（VectorSource）**

- `new VectorSource({ features: [feature1, feature2, ...] })`

**4. 创建图层（VectorLayer）并绑定数据源**

- `new VectorLayer({ source: vectorSource, style: styleObj })`

**5. 将图层添加到地图（Map）中**

- `map.addLayer(vectorLayer)`

**6. 设置样式（Style）**

- 使用 `new Style({ fill, stroke, image })` 设置点、线、面的样式。
- 样式可以在创建 `Feature` 时单独设置，也可以在 `VectorLayer` 上统一设置。

**7. 调整视角（View）**

- 如果想让地图自动缩放到几何范围，可以用：

```js
map.getView().fit(feature.getGeometry().getExtent(), { padding: [20, 20, 20, 20] });
```

**示例代码**

```js
 // === Step 1: 使用对应的坐标创建 Polygon 的几何对象 ===
    // 原始经纬度坐标（WGS84）
    const rawCoords = [
      [105.2355, 26.7146],
      [105.255,   26.7182],
      [105.2544,  26.7134],
      [105.235,   26.7096],
      [105.2355,  26.7146] // 闭合点（若未闭合，下面示例会自动闭合）
    ];

    // 确保闭合（第一点等于最后一点）
    if (!(rawCoords[0][0] === rawCoords[rawCoords.length - 1][0] &&
          rawCoords[0][1] === rawCoords[rawCoords.length - 1][1])) {
      rawCoords.push(rawCoords[0]);
    }

    // 把经纬度转换为 Web Mercator（OpenLayers 底图通常是 EPSG:3857）
    const coords3857 = rawCoords.map(c => fromLonLat(c));

    // 创建 Polygon（传入一个线环数组）
    const polygonGeom = new Polygon([coords3857]);

    // === Step 2: 使用这个几何对象创建一个 Feature ===
    const polygonFeature = new Feature({ geometry: polygonGeom });

    // === Step 3: 创建 VectorSource，并设置 features ===
    const vectorSource = new VectorSource({
      features: [ polygonFeature ]
    });

    // === Step 4 & 5: 创建 VectorLayer，设置 source 并设置 style ===
    const polygonStyle = new Style({
      stroke: new Stroke({ color: 'rgba(0,123,255,1)', width: 2 }),
      fill:   new Fill({ color: 'rgba(0,123,255,0.16)' })
    });

    const vectorLayer = new VectorLayer({
      source: vectorSource,
      style: polygonStyle
    });

	// 注意图层的index，按需设置
	vectorLayer.setZIndex(10);

    // === 地图（先创建底图） ===
    const map = new Map({
      target: 'map',
      layers: [
        new TileLayer({ source: new OSM() })
      ],
      view: new View({
        // 临时中心（后面会用 fit 自动定位）
        center: fromLonLat([105.245, 26.714]),
        zoom: 14
      })
    });

    // === Step 6: 把 VectorLayer 添加到地图上 ===
    map.addLayer(vectorLayer);
	
    // === Step 7: 调整视角（让视图适配多边形范围） ===
    map.getView().fit(polygonGeom.getExtent(), {
      padding: [40, 40, 40, 40],
      maxZoom: 18,
      duration: 300
    });
```



### 2. 后端直接返回一个 **GeoJSON 格式的 **数据

后端返回的数据是`GeoJSON`格式的，这个数据可能是单独一个几何对象`Geometry`，也可以是一个`Feature`，还可能是一个`FeatureCollection`

示例1：后端返回的数据是`FeatureCollection`：

```js
// 假设这是后端返回的 GeoJSON 数据
const geojsonData = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": { "name": "Polygon 示例" },
      "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [120, 30],
            [121, 30],
            [121, 31],
            [120, 31],
            [120, 30]
          ]
        ]
      }
    },
    {
      "type": "Feature",
      "properties": { "name": "Point 示例" },
      "geometry": {
        "type": "Point",
        "coordinates": [120.5, 30.5]
      }
    }
  ]
};
```

在地图上显示

```js
// 1. 用 GeoJSON 格式化工具把数据解析为 OpenLayers 要素
const features = new GeoJSON().readFeatures(geojsonData, {
  dataProjection: "EPSG:4326",   // 后端坐标系，一般是 WGS84
  featureProjection: "EPSG:3857" // 地图坐标系，通常是 Web Mercator
});

// 2. 放到矢量数据源里
const vectorSource = new VectorSource({
  features: features
});

// 3. 创建图层（可以设置样式）以及  zIndex
const vectorLayer = new VectorLayer({
  source: vectorSource,
  style: new Style({
    stroke: new Stroke({
      color: "blue",
      width: 2
    }),
    fill: new Fill({
      color: "rgba(0, 0, 255, 0.1)"
    }),
    image: new CircleStyle({
      radius: 6,
      fill: new Fill({ color: "red" }),
      stroke: new Stroke({ color: "#fff", width: 2 })
    })
  })
});

// 4. 添加到 map
map.addLayer(vectorLayer);
```



如果后端返回的是一个**Geometry**（例如单独的 `Point` 或 `Polygon`）

需要先包装成一个 `Feature`，再交给 OpenLayers 渲染：



### 在已有的矢量图层上继续添加矢量，同时保留之前的矢量图形

OpenLayers 的 `VectorLayer` 本质上是

依赖 **一个 `VectorSource`** 存放要素（`Feature`）。只要往 **同一个 `VectorSource`** 里不断添加新的 `Feature`，就能在同一个图层上继续显示其它图形，而原来的也会保留。

向

```js
// 假设你已经有了 vectorLayer
const source = vectorLayer.getSource();

// 新建一个 feature
const newFeature = new Feature({
  geometry: new Point(fromLonLat([105.24, 26.71]))
});

// 添加到同一个 source
source.addFeature(newFeature);

// v9.2.4版本中新增了addFeatures，
// 如果是单独的一个feature可以使用addFeature
// 如果是feature集合使用addFeatures
```

这样 `vectorLayer` 上原有的要素不会消失，新的要素会叠加进去。



如果后端返回的是geojson格式的数据，就需要

```js
// 假设后端返回的 GeoJSON FeatureCollection
const geojsonData = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "Polygon",
        "coordinates": [[[105.2355,26.7146],[105.255,26.7182],[105.2544,26.7134],[105.235,26.7096],[105.2355,26.7146]]]
      },
      "properties": { "name": "多边形1" }
    },
    {
      "type": "Feature",
      "geometry": {
        "type": "Point",
        "coordinates": [105.245,26.715]
      },
      "properties": { "name": "点1" }
    }
  ]
};


// === 1. 解析 GeoJSON，得到 Feature[] ===
const features = new GeoJSON().readFeatures(geojsonData, {
  dataProjection: "EPSG:4326",   // 后端一般是经纬度坐标
  featureProjection: "EPSG:3857" // 转换为 Web Mercator（和地图底图一致）
});

// === 2. 获取已有图层的 source ===
const source = vectorLayer.getSource();

// === 3. 添加 features（不会清空原有的）===
source.addFeatures(features);

// === （可选）4. 让视图适配新增数据 ===
map.getView().fit(source.getExtent(), {
  padding: [20, 20, 20, 20],
  duration: 500
});
```

