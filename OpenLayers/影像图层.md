## 🗺️ 什么是影像图层（Raster Layer）

**影像图层**指的是在地图中**用图片瓦片拼接出来的底图**，它不是几何要素，而是纯图像。
 这些图像数据可以来自：

- 卫星影像（Satellite imagery）
- 航空摄影图
- 道路/地形图的切片瓦片（比如 OSM、Google、Bing 地图）
- WMTS / WMS 等地图服务提供的栅格图像

在 OpenLayers 中，它通常由 `TileLayer`（瓦片图层）承载，使用 `OSM`、`XYZ`、`WMTS`、`TileWMS` 等 **raster 类型的数据源**加载。

### 💡 什么时候会用到影像图层

影像图层通常作为**地图的背景图层**存在，用来给用户提供地理参照环境：

- 显示真实地表背景（比如卫星影像）
- 显示道路、行政区、地形、地名等基础信息（矢量切片渲染成的瓦片）
- 为上面叠加的矢量图层提供空间参照
- 作为不可交互的地图底图（所有交互都发生在矢量图层）

📝 举例：

- 地理信息系统（GIS）应用中，用卫星图作为底图，在上面绘制地块边界。
- 导航地图，用 OSM 瓦片作为底图，在上面显示路线、当前位置等。



### 🧩 OpenLayers 中影像图层的基本使用

```js
import Map from 'ol/Map';
import View from 'ol/View';
import TileLayer from 'ol/layer/Tile';
import OSM from 'ol/source/OSM';

const map = new Map({
  target: 'map',
  layers: [
    new TileLayer({
      source: new OSM(),  // 这是一个 raster 数据源
    })
  ],
  view: new View({
    center: [0, 0],
    zoom: 2,
  })
});
```

这里的 `TileLayer + OSM` 就是一个**典型影像图层**。



### ⚙️ 影像图层可以进行的操作

虽然影像图层本质是图片，但 OpenLayers 仍然提供了一些**图层级别的控制操作**：

| 操作                                | 说明                  |
| ----------------------------------- | --------------------- |
| `setVisible(true/false)`            | 控制图层显隐          |
| `setOpacity(0~1)`                   | 设置图层透明度        |
| `setZIndex(number)`                 | 控制图层叠放顺序      |
| `setExtent(extent)`                 | 限制图层显示区域      |
| `getSource().refresh()`             | 重新加载瓦片数据      |
| `getSource().updateParams()`        | 更新 WMS 等服务的参数 |
| `getSource().setTileLoadFunction()` | 自定义瓦片加载方式    |

**注意**：影像图层**不能直接添加要素、不能触发点击选择等交互事件**，因为它只是图像，没有要素数据。



### 📌 影像图层的常见类型（数据源）

| 数据源类型            | 描述                    | 适用场景                |
| --------------------- | ----------------------- | ----------------------- |
| `OSM`                 | OpenStreetMap 瓦片      | 通用道路地图背景        |
| `XYZ`                 | 通用 URL 模板瓦片       | 接入第三方自定义切片    |
| `TileWMS`             | 基于 WMS 协议的瓦片服务 | 政府/企业提供的地图服务 |
| `WMTS`                | 瓦片化的地图服务        | 高性能、高缓存场景      |
| `BingMaps` / `Google` | 商用卫星图服务          | 高清卫星影像背景        |



### 🧠 理解它和矢量图层的区别

| 项目           | 影像图层 (Raster) | 矢量图层 (Vector)   |
| -------------- | ----------------- | ------------------- |
| 数据本质       | 图片瓦片          | 要素（几何+属性）   |
| 是否可交互     | ❌ 否              | ✅ 是                |
| 是否能添加要素 | ❌ 否              | ✅ 是 (`addFeature`) |
| 主要用途       | 背景底图          | 显示/编辑/交互对象  |



### 📌 总结

**影像图层（Raster Layer）核心特点：**

- 只能显示背景图像，不能承载矢量要素
- 无法直接交互（不能点击某个道路或山脉）
- 提供地图背景、地理参照
- 支持显隐、透明度、顺序等图层级控制





## 🧩 多个影像图层叠加的典型用法

### ① 多底图图层（只显示一个，其余隐藏）

- 例如提供「卫星图」「街道图」「地形图」三种背景
- 它们同时存在于 `map.layers` 中
- 但每次只设置一个为 `visible: true`，其他设为 `false`

```js
const satellite = new TileLayer({ source: new XYZ({ url: '...' }), visible: false });
const street = new TileLayer({ source: new OSM(), visible: true });
const terrain = new TileLayer({ source: new XYZ({ url: '...' }), visible: false });

map.addLayer(satellite);
map.addLayer(street);
map.addLayer(terrain);

// 切换底图
satellite.setVisible(true);
street.setVisible(false);
```

📝 这是最常见的做法，便于用户切换地图背景。



### ② 多个叠加图层（同时显示）

多个影像图层可以**同时显示**在一起

通过 `opacity` 和 `zIndex` 来控制它们的混合效果和顺序

```js
const baseMap = new TileLayer({ source: new OSM(), zIndex: 0 });
const hillshade = new TileLayer({ source: new XYZ({ url: '...' }), opacity: 0.5, zIndex: 1 });
const labels = new TileLayer({ source: new XYZ({ url: '...' }), zIndex: 2 });

map.addLayer(baseMap);
map.addLayer(hillshade);
map.addLayer(labels);
```

📌 常见用途：

- 底图（OSM） + 阴影地形层（半透明）+ 地名注记层
- 卫星图 + 道路网络（半透明）



##### ⚙️ 多个影像图层时的注意点

| 项目      | 说明                                           |
| --------- | ---------------------------------------------- |
| `zIndex`  | 控制图层的叠放顺序（数字大在上层）             |
| `opacity` | 可以让上层图层半透明显示                       |
| `visible` | 用来切换显示/隐藏图层                          |
| 性能      | 图层越多同时加载的瓦片请求越多，会增加网络压力 |



### 图层切换（Layer Switch）

#### 🅐 保留所有图层，用 `setVisible()` 控制显隐

**做法：**

- 初始化时把所有影像图层都 `map.addLayer()` 添加到地图。
- 切换时只是调用 `layer.setVisible(true / false)` 控制显示与隐藏。

```js
// 初始化时
const layerA = new TileLayer({ source: new XYZ({ url: '...' }), visible: true });
const layerB = new TileLayer({ source: new XYZ({ url: '...' }), visible: false });
map.addLayer(layerA);
map.addLayer(layerB);

// 切换显示B
layerA.setVisible(false);
layerB.setVisible(true);
```

**优点：**

- 切换非常快，不需要重新加载。
- 状态保留（如果图层内部有缓存、加载进度、瓦片缓存等）。

**缺点：**

- 同时保留所有图层会占用更多内存和网络缓存。
- 初始化加载时间较长（因为一开始就要准备多个图层）。

**适合：**

- 图层数量不多（2~3个）。
- 用户频繁切换，要求切换迅速。



#### 🅑 切换时移除旧图层再添加新图层

**做法：**

- 只在地图上保留一个当前图层。
- 每次切换时先 `map.removeLayer(oldLayer)` 再 `map.addLayer(newLayer)`。

```js
let currentLayer = layerA;
map.addLayer(currentLayer);

function switchTo(layer) {
  map.removeLayer(currentLayer);
  currentLayer = layer;
  map.addLayer(currentLayer);
}
```

**优点：**

- 内存占用少，地图只维护一个图层。
- 初始化更快，初始只加载一个图层。

**缺点：**

- 每次切换需要重新加载图层资源。
- 切换过程可能有短暂空白闪烁。

**适合：**

- 图层种类很多，但用户只会偶尔切换。
- 单个图层资源很大（节省内存）。



#### 📝 小结

| 方式              | 优点               | 缺点                 | 适用场景           |
| ----------------- | ------------------ | -------------------- | ------------------ |
| `setVisible`      | 切换快、保留状态   | 内存占用高、初始化慢 | 少量图层、频繁切换 |
| `remove/addLayer` | 节省内存、初始化快 | 切换慢、重新加载     | 多图层、偶尔切换   |



#### 📌 10 个图层时的选择

| 方式                                  | 优点                                 | 缺点                                               | 在 10 个图层场景下的表现                               |
| ------------------------------------- | ------------------------------------ | -------------------------------------------------- | ------------------------------------------------------ |
| **全部添加，用 `setVisible()` 控制**  | 切换快，无需重新加载，保留缓存状态   | 初始加载会发出所有图层的网络请求，占内存和网络带宽 | ⚠️ **首次加载会很慢**、内存占用较高，浏览器卡顿风险增加 |
| **切换时 `removeLayer` / `addLayer`** | 节省内存和网络，只加载当前需要的图层 | 切换要重新加载，用户会看到短暂空白                 | ✅ 首次加载快，内存占用小，更适合一次只看一层           |

##### 📝 总结建议

- **如果这 10 个图层通常只显示 1 个或少数几个**（典型的「底图切换」场景），建议使用
   🔹**第二种方式：动态 `remove/addLayer`**
   这样可以避免浏览器一开始就加载 10 份瓦片数据，减少内存和带宽压力。
- **如果这 10 个图层会经常叠加显示多个（如专题图叠加）**，才适合
   🔹**第一种方式：一次性添加，用 `setVisible` 控制**
   因为你需要同时显示它们，就必须都加载进来。



💡 实际常见做法

在项目里常见做法是**混合使用**：

- 一组互斥的**底图图层**（影像底图、矢量底图、地形底图） → 用 `remove/addLayer` 切换
- 一些可选的**叠加图层**（行政区划线、道路网、标注点等） → 全部添加，用 `setVisible` 控制