### OpenLayers集成示例

#### 1. 目录结构

```mathematica
src/
├── composables/
│   └── map/
│       ├── index.ts           # (可选) 统一导出
│       ├── types.ts           # 【重点】地图相关的类型定义都在这，模块化导出
│       ├── useOlMap.ts        # 核心逻辑
│       └── useMapControls.ts  # 交互逻辑
├── components/
│   └── BaseMap/
│       └── index.vue
└── types/
    └── business.d.ts          # 只有纯业务数据（如后端API返回的结构）才放这
```



### 2. 安装依赖

OpenLayers 自带了 TypeScript 类型定义，所以只需要安装主包即可：

```ini
npm install ol
```



### 3. 核心实现： 组件与Hooks 

#### 第一步：定义类型 `src/composables/map/types.ts`

这里只放纯类型定义，不放逻辑。

这个根据业务逻辑实现，不适用TS就不需要该文件。

```ts
// src/composables/map/types.ts

import type { Coordinate } from "ol/coordinate";

// 1. 定义点位类型枚举 (用于代码提示)
export type PointType = "normal" | "warning" | "offline";

// 2. 修改点位数据接口
export interface MarkerData {
  id: string | number;
  name: string;
  position: Coordinate;
  type: PointType; // 必填：决定了图标长什么样
  description?: string;
}

// 定义初始化配置的接口
export interface MapConfig {
  center?: Coordinate; // 经纬度 [经度, 纬度]
  zoom?: number;
  projection?: string;
}

// 定义颜色配置 (导出供 hook 使用)
export const COLOR_CONFIG: Record<PointType, string> = {
  normal: "#409EFF", // 蓝色
  warning: "#F56C6C", // 红色
  offline: "#909399", // 灰色
};
```



#### 第二步：编写核心 Hook (src/composables/map/useOlMap.ts)

这里我们利用 TS 定义接口，并严格管理地图实例的类型。

这里实现地图初始化，初始化需要知道挂载的`DOM`，需要给出初始化`配置options`，这样就确定了这个Hook所需要的参数。

```ts
import "ol/ol.css";
import Map from "ol/Map";
import View from "ol/View";
import TileLayer from "ol/layer/Tile";
import OSM from "ol/source/OSM";
import type { MapConfig } from "./types";

export function useOlMap(domRef: Ref<HTMLElement | null>, config: MapConfig = {}) {
  // 使用 shallowRef 或 ref 存储地图实例
  // 注意：OpenLayers 的 Map 对象非常复杂，必须使用 markRaw 避免 Vue 进行深度代理，否则会造成严重的性能问题
  const mapInstance = ref<Map | null>(null);

  const initMap = (): Map | undefined => {
    if (!domRef.value) return;

    // 默认配置，注意坐标系的设置
    const { center = [120.2, 30.3], zoom = 15, projection = "EPSG:4326" } = config;

    const map = new Map({
      target: domRef.value,
      layers: [
        new TileLayer({
          source: new OSM(), // 这里演示使用 OSM，项目中可替换为天地图/高德等
        }),
      ],
      view: new View({
        // 不设置projection 默认坐标系是 EPSG:3857，经纬度不能直接显示
        // 调整坐标系为 EPSG:4326,可以直接使用经纬度坐标
        center: center,
        zoom: zoom,
        projection: projection,
      }),
    });

    // 标记为非响应式对象，避免性能问题
    mapInstance.value = markRaw(map);
    return map;
  };

  // 销毁地图
  onUnmounted(() => {
    if (mapInstance.value) {
      mapInstance.value.setTarget(undefined);
      mapInstance.value = null;
    }
  });

  return {
    mapInstance,
    initMap,
  };
}
```



#### 第三步：编写通用组件 (src/components/BaseMap/index.vue)

该组件不对外暴露复杂的逻辑，只负责挂载 DOM，并通过 `emit` 将**地图实例**交给**父组件**。

```vue
<script setup lang="ts">
import Map from "ol/Map";
import { useOlMap } from "@/composables/map/useOlMap";
import type { MapConfig } from "@/composables/map/types";

// 定义 Props
interface Props {
  options?: MapConfig;
}

const props = withDefaults(defineProps<Props>(), {
  options: () => ({
    center: [120.15, 30.28],
    zoom: 12,
  }),
});
// 定义 Emits
const emit = defineEmits<{
  (e: "map-loaded", map: Map): void;
}>();

const mapContainer = ref<HTMLElement | null>(null);

const { initMap } = useOlMap(mapContainer, props.options);

onMounted(() => {
  const map = initMap();
  if (map) {
    // 将地图实例交给父组件,方便其它业务实现
    emit("map-loaded", map);
  }
});
</script>

<template>
  <div ref="mapContainer" class="w-full h-full overflow-hidden relative"></div>
</template>

<style scoped lang="scss"></style>
```



### 4. 集成到业务组件

现在修改你的 `views/four-conditions/index.vue`。

```vue
<template>
  <div class="four-monitor p-4">
    <div class="cards mb-4">
      <!-- 省略 -->
    </div>

    <div class="middle mb-4">
      <el-card shadow="hover" :body-style="{ padding: '0px' }">
        <!-- 省略 -->
        
        <!-- 地图容器：注意这里一定要给具体高度，或者父级有高度 -->
        <div class="w-full h-[350px] bg-[#c9ced6]">
          <BaseMap 
            :options="mapOptions"
            @map-loaded="onMapReady"
          />
        </div>
      </el-card>
     
      <el-card shadow="hover">Hover</el-card>
    </div>

  </div>
</template>

<script setup lang="ts">
import BaseMap from "@/components/BaseMap/index.vue";
    
import type { MapConfig } from "@/composables/map/useOlMap"; 
import type { MarkerData } from "@/composables/map/types";
import type Map from "ol/Map";

//  地图配置
const mapOptions: MapConfig = {
  center: [120.19, 30.26], // 杭州示例
  zoom: 11,
};

// 保存地图实例引用 使用 shallowRef
const mapInstance = shallowRef<Map | null>(null);

// 地图加载完成后执行的回调，接收到地图实例map，存储下来
const onMapReady = (map: Map) => {
  console.log("OpenLayers Map Initialized:", map);
  mapInstance.value = markRaw(map);
  console.log("map实例", mapInstance.value);
};
</script>

<style scoped>
/* 你的样式 */
</style>
```



### 关键点总结 

1. **类型安全**：
   - 在 `types.ts` 中定义了 `MapConfig` 接口，父组件传参时如果不符合结构（例如传了字符串给zoom）IDE 会报错。
   - 使用 `Ref<HTMLElement | null>` 明确 DOM 引用的类型。
   - `onMapReady` 回调明确接收 `Map` 类型对象，后续调用 `map.addLayer` 等方法时会有完美的代码提示。
2. **避免 Vue 代理 (markRaw)**：
   - 这是一个常见坑。Vue 3 的 `ref` 或 `reactive` 默认是深层代理。OpenLayers 的 `Map` 对象内部包含了大量的 DOM 引用和循环引用，如果被 Vue 代理，不仅性能极差，还可能导致地图交互卡顿甚至报错。
   - 解决方案：`mapInstance.value = markRaw(map);`
3. **解耦与复用**：
   - 你在其他组件想用地图，直接引入 `<BaseMap />`。
   - 你在其他组件想实现测距功能？写一个 `useMeasure(map)` 的 hook。
   - 你在其他组件想做热力图？写一个 `useHeatmap(map)` 的 hook。
   - `BaseMap` 永远保持干净，只负责 "显示一个框"。
4. **关于 `id="map-container"`**：
   - 在 Vue 组件化开发中，**坚决避免**使用硬编码的 `id` 来初始化插件（如 `id="map-container"`）。
   - 原因：如果页面上有两个组件都用了这个地图组件，或者使用了 `v-if` 切换，硬编码 `ID` 会导致找不到元素或冲突。
   - 解决方案：使用 `ref="mapContainer"` 获取具体的 DOM 节点传给 OpenLayers 的 `target` 属性。

