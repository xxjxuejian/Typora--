



`type.ts`

```ts
import type { Coordinate } from "ol/coordinate";

// 1. 定义点位类型枚举 (用于代码提示)
export type PointType = "normal" | "warning" | "offline";

// 2. 修改点位数据接口
export interface MarkerData {
  id: string | number;
  name: string;
  position: Coordinate;
  type: PointType; // 必填：决定了图标长什么样
  description?: string;
}

// 定义初始化配置的接口
export interface MapConfig {
  center?: Coordinate; // 经纬度 [经度, 纬度]
  zoom?: number;
  projection?: string;
}

// 定义颜色配置 (导出供 hook 使用)
export const COLOR_CONFIG: Record<PointType, string> = {
  normal: "#409EFF", // 蓝色
  warning: "#F56C6C", // 红色
  offline: "#909399", // 灰色
};
```



`useMarkerSystem.ts`

```ts
import { ref, type Ref } from "vue";
import Map from "ol/Map";
import Feature from "ol/Feature";
import Point from "ol/geom/Point";
import { Vector as VectorSource } from "ol/source";
import { Vector as VectorLayer } from "ol/layer";
import { Style, Text, Fill, Stroke, Circle } from "ol/style";
import Overlay from "ol/Overlay";
import { getVectorContext } from "ol/render";
import { COLOR_CONFIG, type MarkerData, type PointType } from "./types";

// 辅助函数：Hex 转 RGB (用于处理透明度)
// 输入 '#F56C6C', 0.5 -> 输出 'rgba(245, 108, 108, 0.5)'
function hexToRgba(hex: string, opacity: number) {
  let c: any = hex.substring(1).split("");
  if (c.length === 3) {
    c = [c[0], c[0], c[1], c[1], c[2], c[2]];
  }
  c = "0x" + c.join("");
  return "rgba(" + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(",") + "," + opacity + ")";
}

// 创建基础样式函数
const createStyle = (feature: Feature, scale = 0.8) => {
  // 1. 获取该点位的业务数据
  const data = feature.get("data") as MarkerData;

  // 2. 根据 type 获取对应的配置，如果没有匹配则使用默认(normal)
  const color = COLOR_CONFIG[data.type] || "#409EFF";

  return new Style({
    image: new Circle({
      radius: 8,
      fill: new Fill({ color: color }),
      stroke: new Stroke({ color: "#fff", width: 2 }),
      scale,
    }),
    text: new Text({
      text: data.name,
      font: "14px sans-serif",
      offsetY: -15,
      fill: new Fill({ color: "#333" }),
      stroke: new Stroke({ color: "#fff", width: 2 }),
    }),
  });
};

export function useMarkerSystem(mapInstance: Ref<Map | null>, popupRef: Ref<HTMLElement | null>) {
  // 选中的点位数据（用于弹窗展示）
  const selectedMarker = ref<MarkerData | null>(null);

  // 保存 Overlay 实例
  let overlayInstance: Overlay | null = null;
  // 保存当前的 VectorLayer
  let vectorLayer: VectorLayer<VectorSource> | null = null;
  // 记录当前鼠标悬停的 Feature，用于恢复样式
  let hoveredFeature: Feature | null = null;

  // 2. 核心动画逻辑
  const animate = (event: any) => {
    // 获取当前帧的上下文
    const vectorContext = getVectorContext(event);
    const frameState = event.frameState;

    // 如果没有 layer 或者 source，直接返回
    if (!vectorLayer) return;
    const features = vectorLayer.getSource()?.getFeatures();
    if (!features) return;

    features.forEach((feature) => {
      const data = feature.get("data") as MarkerData;

      // 只有 'warning' 和 'normal' 类型的点才闪烁，'offline' 不闪
      //   if (data.type === "offline") return;

      const colorHex = COLOR_CONFIG[data.type];

      // 动画算法：利用时间戳产生周期性变化 (2秒一个周期)
      // frameState.time 是当前时间的毫秒数
      const period = 2000;
      const start = feature.get("start");
      // 如果没有记录开始时间，就存一下
      if (!start) {
        feature.set("start", new Date().getTime());
        return;
      }

      // 计算当前动画进度 (0 ~ 1)
      const elapsed = frameState.time - start;
      const ratio = (elapsed % period) / period;

      // 计算半径：从 5 扩散到 20
      const radius = 5 + 25 * ratio;
      // 计算透明度：从 0.8 渐变到 0
      const opacity = 1 * (1 - ratio);

      // 创建动态样式 (波纹)
      const rippleStyle = new Style({
        image: new Circle({
          radius: radius,
          stroke: new Stroke({
            color: hexToRgba(colorHex, opacity), // 动态颜色
            width: 1.5 + ratio, // 边框稍微变粗一点点
          }),
        }),
      });

      // 将波纹绘制到 Canvas 上
      // 注意：这里必须重新设置 Geometry，否则位置不对
      vectorContext.setStyle(rippleStyle);
      vectorContext.drawGeometry(feature.getGeometry()!);
    });

    // 关键：告诉地图立即渲染下一帧，形成流畅动画
    // 注意：如果有性能问题，可以限制刷新频率
    mapInstance.value?.render();
  };

  // 2. 添加点位到地图
  const addMarkers = (dataList: MarkerData[]) => {
    if (!mapInstance.value) return;

    const features = dataList.map((item) => {
      const feature = new Feature({
        geometry: new Point(item.position),
      });
      // 将业务数据绑定到 Feature 上，方便后续获取
      feature.set("data", item);
      //   feature.set("start", new Date().getTime() + Math.random() * 1000); // 随机启动时间，让波纹错开
      feature.setStyle(createStyle(feature));
      return feature;
    });

    const source = new VectorSource({ features });
    vectorLayer = new VectorLayer({
      source,
      zIndex: 10,
    });
    vectorLayer.on("postrender", animate);
    mapInstance.value.addLayer(vectorLayer);
  };

  // 3. 初始化弹窗 Overlay
  const initOverlay = () => {
    if (!mapInstance.value || !popupRef.value) return;

    overlayInstance = new Overlay({
      element: popupRef.value,
      // autoPan: true, // 弹窗超出屏幕时自动平移地图
      positioning: "bottom-center", // 弹窗在坐标点上方
      offset: [0, -50], // 向上偏移，避开图标
    });
    mapInstance.value.addOverlay(overlayInstance);
  };

  // 4. 绑定交互事件 (Hover & Click)
  const bindInteractions = () => {
    const map = mapInstance.value;
    if (!map) return;

    // --- 鼠标移动事件 (Hover 放大) ---
    map.on("pointermove", (e) => {
      if (e.dragging) return; // 拖拽时不处理

      // e.pixel 是当前鼠标的像素坐标,相对于 地图容器的
      // 判断鼠标当前指向的这个像素附近，有没有图层上的 feature
      const hit = map.forEachFeatureAtPixel(e.pixel, (feature) => feature);
      // 返回 OpenLayers 地图真正挂载的那个 DOM 元素。
      const mapTarget = map.getTargetElement();

      // 如果当前有悬停 Feature，且不是新的 hit，则恢复原样
      if (hoveredFeature && hoveredFeature !== hit) {
        hoveredFeature.setStyle(createStyle(hoveredFeature as Feature, 0.8)); // 恢复默认大小
        hoveredFeature = null;
        mapTarget.style.cursor = ""; //恢复鼠标指针
      }

      // 如果鼠标下有 Feature
      if (hit) {
        const feature = hit as Feature;
        // 简单判断是不是我们的点位 (根据是否有 data 属性)
        if (feature.get("data")) {
          hoveredFeature = feature;
          feature.setStyle(createStyle(feature, 1.2)); // 放大到 1.2 倍
          mapTarget.style.cursor = "pointer"; // 鼠标变手型
        }
      }
    });

    // --- 点击事件 (Click 弹窗) ---
    map.on("click", (e) => {
      if (!popupRef.value) return;
      const feature = map.forEachFeatureAtPixel(e.pixel, (feature) => feature);

      if (feature && feature.get("data")) {
        // 点击到了点位
        const data = feature.get("data") as MarkerData;
        selectedMarker.value = data; // 更新 Vue 数据

        // 设置弹窗位置 (使用 Feature 的坐标)
        const geometry = feature.getGeometry() as Point;
        overlayInstance?.setPosition(geometry.getCoordinates());
      } else {
        // 点击空白处，关闭弹窗
        closePopup();
      }
    });
  };

  // 关闭弹窗方法
  const closePopup = () => {
    overlayInstance?.setPosition(undefined); // undefined 会隐藏 Overlay
    selectedMarker.value = null;
  };

  // 清理逻辑
  onUnmounted(() => {
    if (vectorLayer) {
      vectorLayer.un("postrender", animate); // 移除监听，防止内存泄漏
    }
  });

  return {
    addMarkers,
    initOverlay,
    bindInteractions,
    selectedMarker, // 暴露给 Vue 模板使用
    closePopup,
  };
}
```



业务组件

```vue
<script setup lang="ts">
import CardTitle from "@/components/CardTitle/index.vue";
import BaseMap from "@/components/BaseMap/index.vue";

// import { useMapControls } from "@/composables/map/useMapControls";
import type { MapConfig } from "@/composables/map/useOlMap"; // 导入类型
// import type Map from "ol/Map";

import { useMarkerSystem } from "@/composables/map/useMarkerSystem";
import type { MarkerData } from "@/composables/map/types";
import type Map from "ol/Map";

const monitorData = ref([
  {
    position: "西区1号",
    area: 15.2,
    greenValue: 3.5,
    ndvi: 0.72,
    status: 1,
  },
  {
    position: "西区2号",
    area: 18.4,
    greenValue: 4.1,
    ndvi: 0.68,
    status: 0,
  },
  {
    position: "东区3号",
    area: 12.9,
    greenValue: 3.0,
    ndvi: 0.75,
    status: 1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
  {
    position: "南区1号",
    area: 20.3,
    greenValue: 4.8,
    ndvi: 0.63,
    status: -1,
  },
]);

// 卡片标题的按钮点击事件
const handleBtnClick = () => {
  ElMessage.success("点击了");
};

// 1. 地图配置
const mapOptions: MapConfig = {
  center: [120.19, 30.26], // 杭州示例
  zoom: 11,
};

// 模拟不同类型的点位
const mockData: MarkerData[] = [
  {
    id: 1,
    name: "正常设备A",
    position: [120.15, 30.28],
    type: "normal", // 使用蓝色图标
    description: "运行良好",
  },
  {
    id: 2,
    name: "报警设备B",
    position: [120.16, 30.29],
    type: "warning", // 使用红色图标
    description: "水位超标！",
  },
  {
    id: 3,
    name: "离线设备C",
    position: [120.14, 30.27],
    type: "offline", // 使用灰色图标
    description: "无法连接",
  },
];

// 3. 保存地图实例引用 使用 shallowRef
const mapInstance = shallowRef<Map | null>(null);
// 弹窗 DOM 引用
const popupRef = ref<HTMLElement | null>(null);

// 引入我们封装好的逻辑
const { addMarkers, initOverlay, bindInteractions, selectedMarker, closePopup } = useMarkerSystem(
  mapInstance,
  popupRef
);
// 4. 地图加载完成的回调
const onMapReady = (map: Map) => {
  console.log("OpenLayers Map Initialized:", map);
  mapInstance.value = markRaw(map);
  console.log("map实例", mapInstance.value);

  initOverlay();
  bindInteractions();

  addMarkers(mockData);

  mapInstance.value.getView().animate({
    center: [120.14, 30.27],
    zoom: 14,
    duration: 1000,
  });
};
</script>

<template>
  <div class="four-monitor p-4">
    <div class="middle mb-4">
      <el-card shadow="hover" class="map-card">
        <template #header>
          <CardTitle
            title-icon="map"
            title-text="监测点位分析"
            btn-icon="seedling"
            btn-text="苗情分析"
            @btn-click="handleBtnClick"
          ></CardTitle>
        </template>
        <!-- 地图容器 -->
        <div class="w-full h-[350px] flex-center bg-[#c9ced6] relative">
          <BaseMap :options="mapOptions" @map-loaded="onMapReady" />

          <!-- 2. 弹窗 DOM (使用 v-show 或样式控制显隐，实际由 OpenLayers 接管位置) -->
          <!-- 注意：ref="popupRef" -->
          <div v-show="selectedMarker" ref="popupRef" class="ol-popup-container">
            <el-card>
              <template #header>
                <div class="font-bold flex justify-between">
                  <span>{{ selectedMarker?.name }}</span>
                  <div class="i-svg:xmark cursor-pointer" @click="closePopup"></div>
                </div>
              </template>

              <div class="text-sm text-gray-600 p-4">
                <div>ID: {{ selectedMarker?.id }}</div>
                <div>描述: {{ selectedMarker?.description || "暂无描述" }}</div>
                <el-button type="primary" size="small" class="mt-2">查看详情</el-button>
              </div>
            </el-card>
          </div>
        </div>
      </el-card>
    </div>
  </div>
</template>

<style scoped lang="scss">
.four-monitor {
  width: 100%;
  height: 100%;
  overflow-y: auto;

  /* 卡片容器 */
  .cards {
    display: flex;
    flex-wrap: wrap;
    gap: 16px; /* 盒子间距 */

    .el-card {
      flex: 1 1 calc(25% - 16px); /* 大屏：4列 */
    }
  }

  /*  监测点位*/
  .middle {
    display: flex;
    gap: 16px; /* 盒子间距 */

    :deep(.map-card) {
      .el-card__body {
        padding: 0;
      }
    }

    .el-card {
      flex: 1 1 0; /* 大屏：4列 */

      &:nth-child(1) {
        flex: 2 1 0; /* 第一个卡片占两倍宽度 */
      }
    }
  }

  /* 监测数据 */
  .footer {
    display: flex;
    gap: 16px;

    .el-card {
      flex: 1 1 0;

      &:nth-child(1) {
        flex: 2 1 0;
      }
    }
  }

  /* 中屏：2列 */
  @media (max-width: 992px) {
    .cards > .el-card {
      flex: 1 1 calc(50% - 16px);
    }

    .middle {
      flex-direction: column;

      .el-card {
        flex: none; // 清除掉原来的 flex 分配
        width: 100%; // 撑满

        &:nth-child(1) {
          flex: none; // 清除掉原来的 flex 分配
          width: 100%; // 撑满
        }
      }
    }

    .footer {
      flex-direction: column;

      .el-card {
        flex: none; // 清除掉原来的 flex 分配
        width: 100%; // 撑满

        &:nth-child(1) {
          flex: none; // 清除掉原来的 flex 分配
          width: 100%; // 撑满
        }
      }
    }
  }

  /* 小屏：1列 */
  @media (max-width: 768px) {
    .cards > .el-card {
      flex: 1 1 100%;
    }
  }
}

/* 弹窗样式 */
.ol-popup-container {
  position: absolute;
  /* 解决初始闪烁问题 */
  display: block;
  /* OpenLayers 会控制 top/left，这里只需要确保它不占位 */
  min-width: 200px;
  background: transparent;
}
</style>

```

