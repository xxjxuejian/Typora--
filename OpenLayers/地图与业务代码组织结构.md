
为了将 OpenLayers 优雅、可维护地集成到 Vue 项目中，并考虑到后续的多处复用和功能拓展（如点位、交互、图层切换），建议采用 **"基础组件 + 组合式函数 (Composables/Hooks)"** 的架构模式。

这种模式的核心思想是：

1. **UI 层**：封装一个通用的 `<BaseMap />` 组件，只负责渲染容器。
2. **逻辑层**：使用 `useMap、useLayer、useInteraction` 等 Hooks 封装 OpenLayers 的核心逻辑。
3. **业务层**：在具体的页面（如你的 index.vue）中，调用 Hooks 操作地图实例。

下面是推荐的代码组织结构和实现步骤。

### 1. 目录结构设计

建议在 `src` 下建立如下结构：

```mathematica
src/
├── components/
│   └── BaseMap/
│       └── index.vue          # 地图通用组件
├── composables/
│   └── map/
│       ├── useOlMap.ts       # 核心：初始化与销毁
│       ├── useMapLayers.ts    # 拓展：图层管理
│       └── useMapControls.ts   # 拓展：交互与点位
├── types/
│   └── map.d.ts               # (可选) 地图相关的类型定义
└── views/
    └── four-conditions/
        └── index.vue          # 业务页面
```

### 2. 安装依赖

OpenLayers 自带了 TypeScript 类型定义，所以只需要安装主包即可：

```ini
npm install ol
```



### 3. 核心实现：Hooks 与 组件

#### 第一步：编写核心 Hook (src/composables/map/useOlMap.ts)

这里我们利用 TS 定义接口，并严格管理地图实例的类型。

```ts
import { ref, onUnmounted, markRaw, type Ref } from 'vue';
import 'ol/ol.css';
import Map from 'ol/Map';
import View from 'ol/View';
import TileLayer from 'ol/layer/Tile';
import OSM from 'ol/source/OSM';
import { fromLonLat } from 'ol/proj';
import type { Coordinate } from 'ol/coordinate';

// 定义初始化配置的接口
export interface MapConfig {
  center?: Coordinate; // 经纬度 [经度, 纬度]
  zoom?: number;
  projection?: string;
}

export function useOlMap(domRef: Ref<HTMLElement | null>, config: MapConfig = {}) {
  // 使用 shallowRef 或 ref 存储地图实例
  // 注意：OpenLayers 的 Map 对象非常复杂，必须使用 markRaw 避免 Vue 进行深度代理，否则会造成严重的性能问题
  const mapInstance = ref<Map | null>(null);

  const initMap = (): Map | undefined => {
    if (!domRef.value) return;

    // 默认配置
    const {
      center = [116.40, 39.90], // 默认北京
      zoom = 10,
    } = config;

    const map = new Map({
      target: domRef.value,
      layers: [
        new TileLayer({
          source: new OSM(), // 这里演示使用 OSM，项目中可替换为天地图/高德等
        }),
      ],
      view: new View({
        // 将经纬度转换为 Web Mercator 坐标系 (EPSG:3857)
        center: fromLonLat(center), 
        zoom: zoom,
      }),
    });

    // 标记为非响应式对象
    mapInstance.value = markRaw(map);
    return map;
  };

  // 销毁地图
  onUnmounted(() => {
    if (mapInstance.value) {
      mapInstance.value.setTarget(undefined);
      mapInstance.value = null;
    }
  });

  return {
    mapInstance,
    initMap,
  };
}
```

#### 第二步：编写通用组件 (src/components/BaseMap/index.vue)

该组件不对外暴露复杂的逻辑，只负责挂载 DOM，并通过 `emit` 将地图实例交给父组件。

```vue
<template>
  <div ref="mapContainer" class="w-full h-full overflow-hidden relative"></div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import Map from 'ol/Map';
import { useOlMap, type MapConfig } from '@/composables/map/useOlMap';

// 定义 Props
interface Props {
  options?: MapConfig;
}

const props = withDefaults(defineProps<Props>(), {
  options: () => ({
    center: [120.15, 30.28],
    zoom: 12
  })
});

// 定义 Emits
const emit = defineEmits<{
  (e: 'map-loaded', map: Map): void
}>();

const mapContainer = ref<HTMLElement | null>(null);

const { initMap } = useOlMap(mapContainer, props.options);

onMounted(() => {
  const map = initMap();
  if (map) {
    emit('map-loaded', map);
  }
});
</script>

<style scoped>
/* 确保父容器有高度，或者在这里指定最小高度 */
</style>
```

#### 第三步：编写业务逻辑拓展 Hook (src/composables/map/useMapControls.ts)

为了演示如何拓展（比如添加点位），我们创建一个专门处理 Feature 的 Hook。

```ts
import Map from 'ol/Map';
import Feature from 'ol/Feature';
import Point from 'ol/geom/Point';
import { Vector as VectorSource } from 'ol/source';
import { Vector as VectorLayer } from 'ol/layer';
import { Style, Circle, Fill, Stroke } from 'ol/style';
import { fromLonLat } from 'ol/proj';
import type { Coordinate } from 'ol/coordinate';

export function useMapControls() {
  
  // 添加简单的圆点标记
  const addPointMarkers = (map: Map, coordinates: Coordinate[]) => {
    
    const features = coordinates.map((coord) => {
      return new Feature({
        geometry: new Point(fromLonLat(coord)),
      });
    });

    // 创建样式
    const style = new Style({
      image: new Circle({
        radius: 6,
        fill: new Fill({ color: '#409EFF' }), // Element Plus 蓝色
        stroke: new Stroke({
          color: '#fff',
          width: 2,
        }),
      }),
    });

    const vectorSource = new VectorSource({
      features: features,
    });

    const vectorLayer = new VectorLayer({
      source: vectorSource,
      style: style,
      zIndex: 10
    });

    map.addLayer(vectorLayer);
    
    return vectorLayer; // 返回图层实例，以便后续移除或操作
  };

  // 比如：切换地图中心
  const flyTo = (map: Map, center: Coordinate, zoom = 14) => {
      map.getView().animate({
          center: fromLonLat(center),
          zoom: zoom,
          duration: 1000
      });
  }

  return {
    addPointMarkers,
    flyTo
  };
}
```

### 4. 集成到业务组件

现在修改你的 `views/four-conditions/index.vue`。不需要 ID，完全组件化。

```vue
<template>
  <div class="four-monitor p-4">
    <div class="cards mb-4">
      <!-- 省略 -->
    </div>

    <div class="middle mb-4">
      <el-card shadow="hover" :body-style="{ padding: '0px' }">
        <!-- 省略 -->
        
        <!-- 地图容器：注意这里一定要给具体高度，或者父级有高度 -->
        <div class="w-full h-[350px] bg-[#c9ced6]">
          <BaseMap 
            :options="mapOptions"
            @map-loaded="onMapReady"
          />
        </div>
      </el-card>
     
      <el-card shadow="hover">Hover</el-card>
    </div>

  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import BaseMap from '@/components/BaseMap/index.vue';
import { useMapControls } from '@/composables/map/useMapControls';
import type { MapConfig } from '@/composables/map/useOlMap'; // 导入类型
import type Map from 'ol/Map';

// 1. 地图配置
const mapOptions: MapConfig = {
  center: [120.19, 30.26], // 杭州示例
  zoom: 11
};

// 2. 引入业务逻辑 Hooks
const { addPointMarkers, flyTo } = useMapControls();

// 3. 保存地图实例引用 (使用 shallowRef 也可以，但这里为了方便直接用 Map 类型)
let mapInstance: Map | null = null;

// 4. 地图加载完成的回调
const onMapReady = (map: Map) => {
  console.log('OpenLayers Map Initialized:', map);
  mapInstance = map;

  // 模拟业务：请求后端数据后添加点位
  const mockPoints = [
    [120.19, 30.26],
    [120.21, 30.29],
    [120.15, 30.24]
  ];
  
  addPointMarkers(map, mockPoints);
};

// 5. 页面交互示例
const handleResetMap = () => {
    if (mapInstance) {
        flyTo(mapInstance, [120.19, 30.26], 12);
    }
};
</script>

<style scoped>
/* 你的样式 */
</style>
```

### 关键点总结 

1. **类型安全**：
   - 在 `useOlMap` 中定义了 `MapConfig` 接口，父组件传参时如果不符合结构（例如传了字符串给zoom）IDE 会报错。
   - 使用 `Ref<HTMLElement | null>` 明确 DOM 引用的类型。
   - `onMapReady` 回调明确接收 `Map` 类型对象，后续调用 `map.addLayer` 等方法时会有完美的代码提示。
2. **避免 Vue 代理 (markRaw)**：
   - 这是一个常见坑。Vue 3 的 `ref` 或 `reactive` 默认是深层代理。OpenLayers 的 `Map` 对象内部包含了大量的 DOM 引用和循环引用，如果被 Vue 代理，不仅性能极差，还可能导致地图交互卡顿甚至报错。
   - 解决方案：`mapInstance.value = markRaw(map);`
3. **解耦与复用**：
   - 你在其他组件想用地图，直接引入 `<BaseMap />`。
   - 你在其他组件想实现测距功能？写一个 `useMeasure(map)` 的 hook。
   - 你在其他组件想做热力图？写一个 `useHeatmap(map)` 的 hook。
   - `BaseMap` 永远保持干净，只负责 "显示一个框"。
4. **关于 `id="map-container"`**：
   - 在 Vue 组件化开发中，**坚决避免**使用硬编码的 `id` 来初始化插件（如 `id="map-container"`）。
   - 原因：如果页面上有两个组件都用了这个地图组件，或者使用了 `v-if` 切换，硬编码 `ID` 会导致找不到元素或冲突。
   - 解决方案：使用 `ref="mapContainer"` 获取具体的 DOM 节点传给 OpenLayers 的 `target` 属性。
