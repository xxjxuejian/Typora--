## 介绍商贸城后台管理系统中的动态路由注册的实现

### 静态路由：

静态路由是项目中的公共路由，不依赖与后端生成。

这些路由通常是系统中所有用户（无论其角色或权限如何）都可以访问的基础页面。

**特点:**

- **通用性**：包含所有用户都能访问的页面，例如登录页、404错误页、首页 (Dashboard) 等。
- **无需权限**：访问这些路由不需要特定的用户权限。
- **预先定义**：在前端项目初始化时就已经被加载到路由实例中。

**部分示例代码 (Vue Router):**

```js
// 注册页
{
    path: '/register',
    name: 'register',
    component: () => import('@/views/register/index.vue'),
    meta: {
      hidden: true
    }
  },
  // 登录页
  {
    path: '/login',
    name: 'login',
    component: () => import('@/views/login/index.vue'),
    meta: {
      hidden: true
    }
  },
  {
    path: '/',
    name: '/',
    component: layout,
    redirect: '/dashboard',
    meta: {
      hidden: false
    },
    children: [
    // 首页
      {
        path: 'dashboard',
        name: 'dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: 'dashboard',
          icon: 'dashBoard',
          hidden: false
        }
      },
    ]
  },
```

### 动态路由：

在用户登录后，根据其角色和权限，由后端返回相应配置信息的路由。前端在获取到这些路由信息后，再动态地将其添加到路由实例中。

这种方式主要用于实现精细化的权限控制，确保不同的用户只能看到和访问他们被授权的菜单和页面。

**特点:**

- **权限控制**：是实现用户权限管理的核心，不同角色的用户会得到不同的路由配置。
- **后端驱动**：路由的结构和可访问性由后端数据决定，更加灵活和安全。
- **按需加载**：用户登录成功后，前端向后端请求权限路由，然后通过 `router.addRoute()`等方法动态注入。



**部分示例代码 (Vue Router):**

```json
        {
          path: '/product-manage',
          component: 'layout',
          name: 'productManage',
          meta: { title: 'productManage', icon: 'productManage', hidden: false },
          children: [
            {
              path: 'on-sale',
              component: 'product-manage/on-sale/index',
              meta: {
                title: 'onSale',
                icon: '',
                hidden: false
              }
            },
            {
              path: 'product-release',
              name: 'productRelease',
              component: 'product-manage/product-release/index',
              meta: {
                title: 'productRelease',
                icon: '',
                hidden: false
              }
            },
            {
              path: 'pre-sale',
              component: 'product-manage/pre-sale/index',
              meta: {
                title: 'preSale',
                icon: '',
                hidden: false
              }
            },
            {
              path: 'image-space',
              component: 'product-manage/image-space/index',
              meta: {
                title: 'imageSpace',
                icon: '',
                hidden: false
              }
            }
          ]
        },
```



### 侧边栏路由显示规则：

#### 首页：

首页一般作为静态路由配置，因为不论是什么类型的用户，通常都可以访问首页。

首页通常是由根路径`/` 重定向到首页`dashboard`的。

比如：根路由是`/`，`redirect: '/dashboard`'，首页通常也使用`layout`模板渲染

根路由下面可能还有一些其它页面，同样使用`layout`模板，但是不显示在侧边栏的路由，比如：个人资料`/profile`，通过点击个人头像可以跳转，但是不显示在侧边栏中。

这里`/`和`首页`的路由结构如下：

```js
 {
    path: '/',
    component: layout,
    redirect: '/dashboard',
    meta: {
      hidden: false
    },
    children: [
      {
        path: 'profile',
        component: () => import('@/views/profile/index.vue'),
        meta: {
          title: 'profile',
          icon: 'personnel',
          hidden: true
        }
      },
      {
        path: 'dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: 'dashboard',
          icon: 'dashBoard',
          hidden: false
        }
      }
    ]
  },
```

根路由`/`下面，除了首页`dashboard`以外，其它的页面的`hidden:false`，都不会显示在侧边栏中，这时候根路由下面只有一个子路由（`dashboard`）需要显示，那么就只显示这一个子路由，直接作为顶层的路由显示，和其它一级路由属于并列关系。



#### 多级路由：

如果父路由的children数组中的子路由只有一个需要显示，那么就只显示这一个子路由

如果父路由的children数组中的子路由全都不用显示，那么就把父路由作为子路由显示

如果父路由的hidden = false，但是children数组为空，同样把父路由作为子路由显示

如果父路由的hidden = false，children数组中有多个需要显示的子级路由，那么就正常显示，显示一级父路由，显示二级的子路由等等。



### 生成路由：

`permission.store.ts`

```js
// @ts-nocheck
import { defineStore } from 'pinia'
import type { RouteRecordRaw } from 'vue-router'
import MenuAPI, { type RouteVO } from '@/api/system/menu.ts'
import { completePath } from '@/utils/menu'
import router, { publicRoutes } from '@/router'

const modules = import.meta.glob('../../views/**/**.vue')
const layout = () => import('@/layout/index.vue')

export const usePermissionStore = defineStore('permissionStore', () => {
  const routes = ref([]) //保存当前用户的所有路由(静态和动态)，
  const hasRoute = ref(false)

  /**
   * 生成动态路由
   */
  function generateDyRoutes() {
    // 表示 Promise 成功时会返回 RouteRecordRaw 类型的数组,,
    // resolve → 接收的参数必须是 RouteRecordRaw[] 类型的数据
    return new Promise<RouteRecordRaw[]>((resolve, reject) => {
      MenuAPI.getRoutes().then((res) => {
        console.log('获取到改用户的动态路由', res.data)

        // 处理路由，变成组件
        const dynamicRoutes = transformRoutes(res.data)
        // 保存全部路由
        routes.value = publicRoutes.concat(dynamicRoutes)
        // 处理路由,path变成完整的路径
        // routes.value = completePath(routes.value)
        console.log('routers', routes.value)

        hasRoute.value = true
        resolve(dynamicRoutes)
      })
    })
  }

  // 移出该用户的全部动态路由,保留静态路由
  const removeRoutes = () => {
    routes.value.forEach((route) => {
      const isExist = publicRoutes.some((item) => item.name === route.name)
      // isExist=false,说明route,不是静态路由,所以可以删除
      if (!isExist) {
        router.removeRoute(route.name)
      }
    })
    hasRoute.value = false
    routes.value = []
    console.log('移出全部动态路由')
  }
  return { routes, hasRoute, removeRoutes, transformRoutes, generateDyRoutes }
})

/**
 * 转换路由数据为组件
 */
const transformRoutes = (routes: RouteVO[]) => {
  const asyncRoutes: RouteRecordRaw[] = []

  routes.forEach((route) => {
    const tmpRoute = { ...route } as RouteRecordRaw
    // 如果对应的组件是layout
    if (tmpRoute.component?.toString() == 'layout') {
      tmpRoute.component = layout
    }
    // 对应的组件是其它的
    else {
      const comp = modules[`../../views/${tmpRoute.component}.vue`]
      if (comp) {
        tmpRoute.component = comp
      } else {
        tmpRoute.component = () => import('@/views/not-found/index.vue')
      }
    }

    if (route.children) {
      tmpRoute.children = transformRoutes(route.children)
    }

    asyncRoutes.push(tmpRoute)
  })

  return asyncRoutes
}
```



### 路由守卫:

```

```



### 侧边栏组件：

`Sidebar/index.vue`

这是侧边栏的根组件

```vue
<template>
  <el-scrollbar>
    <SidebarMenu :data="permissionStore.routes" base-path="" />
  </el-scrollbar>
</template>

<script setup>
// 这个页面可以设置布局
import SidebarMenu from './components/SidebarMenu.vue'
import { usePermissionStore } from '@/stores/modules/permission'

const permissionStore = usePermissionStore()
</script>
```



`SidebarMenu.vue`







`el-menu`组件中：

![image-20250730111039901](./../typora-pic/image-20250730111039901.png)

配合`el-sub-menu`和`el-menu-item`使用时，必须给`index`属性，这个属性时必填的。它的作用是`唯一的标识`每一条路由。

在启用 `vue-router` 模式以后，在激活导航时以 `index` 作为 `path` 进行路由跳转 使用 `default-active` 来设置加载时的激活项。这里的`index`必须是一个完整路径，比如：

```js
{
  path: '/product-manage', 
  component: 'layout',
  children: [
    {
      path: 'on-sale', // 注意：相对路径
      component: 'product-manage/on-sale/index',
    }
  ]
}
```

对应到`el-menu`中，开启`router`模式：

```vue
<el-menu :default-active="$route.path" router>
  <el-sub-menu index="/product-manage">
    <template #title>商品管理</template>
    <el-menu-item index="/product-manage/on-sale">在售商品</el-menu-item>
  </el-sub-menu>
</el-menu>
```

> <el-sub-menu index="/product-manage">
>
> 和
>
> <el-sub-menu index="/product-manage">
>
> index = '完整的路由路径'

基于这一点，后端返回的路由中，可以给出每一个路由的完整路径。如果后端没有返回完整路径，就要前端来手动处理。

由于本系统中后端没有给出每一条`route`的完整路径，所以需要前端处理。路径组件`SidebarMenu.vue`中的`base-path`正是为了计算完整路径而设计的。





### 错误：

使用path-browserify包：

```
import path from 'path-browserify'
 ReferenceError: process is not defined
```

使用path-browserify-esm 替换 path-browserify，还是报错，

直接使用

```
import path from 'https://cdn.jsdelivr.net/npm/path-browserify-esm/index.esm.js';
```

