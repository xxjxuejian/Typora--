

## 一、requestRenderMode

`requestRenderMode` 是 CesiumJS 中一个非常重要的性能优化参数，它的核心含义是**决定渲染循环的模式**。

简单来说，它可以让 Cesium 从默认的“持续渲染”模式切换到“按需渲染”模式。

### 两种模式的对比

#### 1. `requestRenderMode: false` (默认模式)
*   **含义**：这是 Cesium 的默认工作方式。它会像游戏引擎一样，以目标帧率（通常是每秒60帧）持续不断地重新渲染场景。
*   **工作方式**：无论场景中的内容是否发生变化，渲染循环都会一直运行，每一帧都重新绘制整个场景。
*   **优点**：对于有持续动画、频繁数据更新或用户频繁交互的动态场景，这种模式能保证最流畅的视觉效果，因为任何变化都能在下一帧立即得到反映。
*   **缺点**：即使场景是完全静止的（例如，用户没有进行任何操作），GPU 和 CPU 也会持续工作，消耗计算资源，导致不必要的电量消耗和设备发热。 对于静态场景，这是一种浪费。

#### 2. `requestRenderMode: true` (按需渲染模式)
*   **含义**：启用此模式后，Cesium 将只在“需要”的时候才渲染新的帧。 这也被称为显式渲染（Explicit Rendering）。
*   **工作方式**：渲染循环在大部分时间处于暂停状态。只有当特定事件发生时，才会触发一次或多次渲染。
*   **优点**：当场景静止时，CPU 和 GPU 的使用率会大幅降低，极大地提升了应用的性能和能效。 对于数据展示、GIS 应用等大部分时间场景不发生变化的场景，性能提升效果非常显著。
*   **缺点**：开发者需要`对场景的变化有更清晰的认知`。因为不是所有操作都会自动触发渲染，所以当你通过 API 修改了场景中的对象（例如，更新一个实体的位置或颜色）后，必须`手动请求一次新的渲染`，否则所做的更改将不会显示在屏幕上。

---

### 何时会触发渲染 (当 `requestRenderMode: true` 时)？

启用按需渲染后，以下情况会**自动**触发新的渲染：
*   **用户交互**：用户通过鼠标或触摸操作移动、缩放或旋转相机。
*   **数据加载**：当新的地形、影像或 3D Tiles 数据加载完成并准备好显示时。
*   **时间变化**：如果场景中有与时间相关的动画或效果（如太阳光照变化、动态数据可视化），当模拟时间变化超过 `viewer.scene.maximumRenderTimeChange` 设定的阈值时，会触发渲染。 对于完全静态的场景，可以将此值设为 `Infinity`。

在以下情况，你需要**手动**触发渲染：
*   **通过 API 修改场景**：当你使用代码添加/删除/修改 `Entity`、`Primitive` 或其他场景元素时，必须调用 `viewer.scene.requestRender()` 来让更改生效。

**手动触发渲染的示例代码：**
```javascript
// 启用按需渲染模式
const viewer = new Cesium.Viewer('cesiumContainer', {
  requestRenderMode: true,
  maximumRenderTimeChange: Infinity // 适用于没有时间动画的静态场景
});


*   CesiumJS 不会持续渲染新的帧，而只在必要时（例如相机位置改变、动画播放等）才进行渲染。
*   当你调用 `viewer.entities.add()` 时，实体被添加到了数据模型中，但**不会**自动触发新的渲染。
*   你需要手动请求一次新的渲染，新添加的实体才会显示出来。这可以通过调用 `viewer.scene.requestRender()` 来实现。

// 添加一个实体
const newEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
  point: {
    pixelSize: 10,
    color: Cesium.Color.RED
  }
});

// 如果不调用 requestRender()，这个红色的点将不会显示出来
// 手动请求一次新的渲染来更新视图
viewer.scene.requestRender();
```

### 总结

`requestRenderMode` 参数是 CesiumJS 性能优化的关键工具。

*   对于**高度动态和持续交互**的应用，使用默认的 `false` 值可以保证最佳的流畅度。
*   对于**大部分时间是静态展示**的应用（如 GIS 数据查看、建筑信息模型展示等），强烈建议将 `requestRenderMode` 设置为 `true`，这可以显著降低系统资源的消耗，并只在必要时通过 `viewer.scene.requestRender()` 手动更新，从而构建一个更加高效和绿色的应用。



## 二、CustomDataSource

好的，这是一个非常核心且重要的问题，理解 `CustomDataSource` 和 `viewer.entities.add()` 的区别是掌握 CesiumJS 数据管理的关键。

简单来说，它们的核心区别在于**管理和组织的层级不同**：

*   `viewer.entities.add()`：是向一个**默认的、全局的“大篮子”**里直接添加一个**单独的**实体。
*   `CustomDataSource`：是先创建一个**独立的、可管理的“小篮子”**，你可以往这个小篮子里添加多个实体，然后再把整个“小篮子”统一添加到 Cesium 中进行管理。

下面我们来详细分解它们的区别。

---

### `viewer.entities.add()`

`viewer.entities` 是一个 `EntityCollection` 对象，它是 `Viewer` 默认创建的一个实体集合。当你调用 `viewer.entities.add()` 时，你正在直接操作这个顶层的集合。

**特点：**

1.  **直接和简单**：这是最直接、最简单的添加单个实体的方法。
2.  **扁平化管理**：所有通过这种方式添加的实体都存在于同一个集合中，没有分组。如果你添加了一千个实体，它们都将平铺在 `viewer.entities` 这个集合里。
3.  **难以批量操作**：如果你想统一隐藏或删除某一批相关的实体，你需要自己遍历 `viewer.entities`，并根据你之前设置的属性（如 `id` 或 `name`）来识别它们，然后逐个进行操作，这非常繁琐。

**代码示例：**
```javascript
// 直接向全局实体集合中添加两个实体
const point = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(-100, 40),
    point: { pixelSize: 10, color: Cesium.Color.RED }
});

const label = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(-102, 40),
    label: { text: 'A single label' }
});

// 如果想隐藏它们，需要分别操作
point.show = false;
label.show = false;
```

---

### `CustomDataSource`

`DataSource` 是一个更高层次的抽象，它被设计用来封装和管理一组相关的数据。`CustomDataSource` 是 `DataSource` 的一个具体实现，允许你手动创建和管理一个数据集。

**特点：**
1.  **分组和封装**：它将一组相关的实体封装在一个独立的容器中。这使得数据的来源和组织结构非常清晰。
2.  **批量控制**：你可以对整个 `DataSource` 进行操作，例如一次性显示/隐藏、添加/删除其中的所有实体。这对于图层管理（Layers）非常有用。
3.  **数据驱动**：`DataSource` API 的设计初衷就是为了加载和表示外部数据（如 GeoJSON, KML, CZML）。`GeoJsonDataSource` 和 `KmlDataSource` 就是专门用于处理这些格式的实现。`CustomDataSource` 给了你手动构建这种结构的能力。
4.  **清晰的事件模型**：`DataSource` 有自己的事件，例如 `changedEvent`，当其内部数据发生变化时会触发。这对于与UI（如数据列表、图层开关）进行交互非常方便。
5.  **与 Viewer 的关系**：你创建的 `DataSource` 实例需要被添加到 `viewer.dataSources` 集合中，它是一个 `DataSourceCollection`。添加后，该 `DataSource` 内部的所有实体会自动地、聚合地显示在 `viewer.entities` 中。也就是说，`viewer.entities` 实际上是一个包含了所有 `DataSource` 中实体的**复合视图**。

**代码示例：**
```javascript
// 1. 创建一个新的、独立的 "小篮子" (DataSource)
const myDataSource = new Cesium.CustomDataSource('myData');

// 2. 向这个 "小篮子" 里添加实体
const pointInDS = myDataSource.entities.add({
    position: Cesium.Cartesian3.fromDegrees(-100, 45),
    point: { pixelSize: 10, color: Cesium.Color.BLUE }
});

const labelInDS = myDataSource.entities.add({
    position: Cesium.Cartesian3.fromDegrees(-102, 45),
    label: { text: 'A grouped label' }
});

// 3. 将整个 "小篮子" 添加到 Viewer 中
viewer.dataSources.add(myDataSource);

// 如果想隐藏这一组实体，只需一行代码！
myDataSource.show = false;

// 如果想移除这一整组实体，也只需一行代码！
// viewer.dataSources.remove(myDataSource);
```

---

### 核心区别对比

| 特性/方面    | `viewer.entities.add()`                                      | `CustomDataSource`                                           |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **管理方式** | 扁平化，所有实体都在一个全局集合中                           | **分组化**，将实体封装在独立的容器中                         |
| **控制粒度** | **单个实体**                                                 | **整个数据源（一组实体）**                                   |
| **批量操作** | 困难，需要手动遍历和识别                                     | **简单**，直接操作 `DataSource` 对象（如 `dataSource.show = false`） |
| **适用场景** | 添加少量、独立的、无需分组管理的实体（如用户点击标记、临时高亮） | 管理一组相关的实体，如图层、来自同一API的数据、需要统一控制的要素 |
| **数据加载** | 通常用于手动、动态创建实体                                   | 设计用于加载和表示数据集，是各类数据格式（GeoJSON等）的基础  |
| **代码结构** | 简单直接                                                     | 结构更清晰，有利于代码的组织和维护                           |

### 总结与建议

*   当你只需要在地图上**添加几个临时的、互相独立的标记**时，使用 `viewer.entities.add()` 是最快最简单的方式。
*   当你需要**加载一组数据**（例如，从服务器获取的所有监测站位置）、**实现图层控制功能**（例如，一个可以被用户打勾显示/隐藏的“监测站”图层）、或者需要对**一组相关的对象进行统一管理**时，**强烈推荐使用 `CustomDataSource`**。

在大型或复杂的 Cesium 应用中，几乎总是会使用 `DataSource` 来组织和管理数据，因为它提供了更好的封装性、可控性和可维护性。