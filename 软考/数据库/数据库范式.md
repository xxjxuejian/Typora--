## 一、第一范式（1NF）

### ✅ 一、1NF 的定义

**第一范式（First Normal Form, 简称 1NF）** 是数据库规范化的最基本要求。

> **定义：**
>  一个关系模式若满足——
>  **所有属性的值都是原子值（即不可再分）**，
>  就称这个关系满足**第一范式（1NF）**。

也就是说，在 1NF 中：

- 每一列（属性）只能存放**单一值**；
- 每一行（记录）表示一个唯一实体；
- 表中**不能有重复组、多值属性或嵌套结构**。

------

### ✅ 二、为什么要有 1NF

1NF 的目的在于：

- 保证数据结构的**简单性与一致性**；
- 让每个字段的值都能被直接比较、查询、更新；
- 为更高层次的规范化（2NF、3NF等）打下基础。

------

### ✅ 三、举例说明

#### 例子 1：❌ 不符合 1NF 的表（有多值属性）

| 学号 | 姓名 | 电话号码                 |
| ---- | ---- | ------------------------ |
| 1001 | 张三 | 13800000000, 13900000000 |

问题：

- “电话号码”字段中有两个号码，用逗号分隔；
- 说明该属性是**多值的**；
- 不符合“属性取值必须是原子值”的要求。

#### ✅改成符合 1NF 的形式（每个属性是原子值）

| 学号 | 姓名 | 电话号码    |
| ---- | ---- | ----------- |
| 1001 | 张三 | 13800000000 |
| 1001 | 张三 | 13900000000 |

说明：

- 我们把每个电话号码拆成一行，
- 这样“电话号码”字段中每个单元格都只有一个值（原子值），
- 现在这个关系就符合 1NF。

#### 例子 2：❌ 不符合 1NF 的表（有重复组）

| 订单号 | 客户 | 商品列表              |
| ------ | ---- | --------------------- |
| A001   | 李四 | {商品A, 商品B, 商品C} |

问题：

- “商品列表”是一个集合（重复组）；
- 属性值不是原子值；
- 不符合 1NF。

------

#### ✅ 改造后符合 1NF 的表

| 订单号 | 客户 | 商品  |
| ------ | ---- | ----- |
| A001   | 李四 | 商品A |
| A001   | 李四 | 商品B |
| A001   | 李四 | 商品C |

说明：

- 把“商品列表”拆开，每行只包含一个商品；
- 每个单元格都存放不可再分的值；
- 符合 1NF。

___



## 二、第二范式（2NF）

### ✅ 一、第二范式（2NF）的定义

> **定义：**
>  在满足 **第一范式（1NF）** 的前提下，
>  **如果一个关系中不存在非主属性对主键的部分依赖**，
>  那么这个关系就满足**第二范式（2NF）**。

#### 🔍 关键词解释：

- **主键（主码）**：唯一标识一条记录的属性（或属性组合）。
- **非主属性**：不是主键组成部分的属性。
- **部分依赖**：指**非主属性仅依赖主键的一部分（不是全部）**。

​	

### ✅ 二、直观理解

第二范式的目标是：

> **消除非主属性对主键的“部分依赖”问题。**

也就是说：

- 如果主键是由**多个字段组成的复合主键**，
- 那么表中**不能存在某个非主属性仅依赖其中一个字段**的情况。

------

### ✅ 三、举例说明（经典例子）

#### ❌ 不符合 2NF 的表（存在部分依赖）

| 学号 | 课程号 | 成绩 | 学生姓名 | 课程名称 |
| ---- | ------ | ---- | -------- | -------- |
| 1001 | C01    | 90   | 张三     | 数据库   |
| 1001 | C02    | 85   | 张三     | 操作系统 |
| 1002 | C01    | 88   | 李四     | 数据库   |

#### 分析：

- 主键 = （学号, 课程号）
   因为一名学生选多门课，单靠“学号”或“课程号”都不能唯一确定一条记录。
- 非主属性有：成绩、学生姓名、课程名称

依赖关系如下：

```ini
(学号, 课程号) → 成绩
学号 → 学生姓名
课程号 → 课程名称
```

🔸 问题：

- “学生姓名”只依赖“学号”（主键的一部分）；
- “课程名称”只依赖“课程号”（主键的一部分）；
- 所以存在**部分依赖** → 不满足 2NF。

### ✅ 改造成符合 2NF 的结构（消除部分依赖）

我们把原表拆成 3 张表：

1️⃣ 学生表

| 学号 | 学生姓名 |
| ---- | -------- |
| 1001 | 张三     |
| 1002 | 李四     |

2️⃣ 课程表

| 课程号 | 课程名称 |
| ------ | -------- |
| C01    | 数据库   |
| C02    | 操作系统 |

3️⃣ 选课表（关联关系）

| 学号 | 课程号 | 成绩 |
| ---- | ------ | ---- |
| 1001 | C01    | 90   |
| 1001 | C02    | 85   |
| 1002 | C01    | 88   |

🔹 改造后：

- 非主属性“成绩”依赖整个主键（学号, 课程号）；
- 不存在非主属性对主键部分依赖；
- 因此三个表都满足**第二范式（2NF）**。

------

### ✅ 四、2NF 的作用

| 作用           | 说明                                 |
| -------------- | ------------------------------------ |
| 消除部分依赖   | 避免非主属性只依赖主键的一部分       |
| 减少数据冗余   | 不再重复保存学生姓名、课程名称等信息 |
| 提高数据一致性 | 改变学生姓名时，不用改多处数据       |





二、主键、候选码、超键

部分依赖

