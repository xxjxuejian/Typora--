## **编译程序工作过程概述**

编译程序的本质是一个翻译器，它将人类可读的高级语言（如 C++, Java）翻译成计算机可执行的机器语言。这个复杂的翻译过程被逻辑上划分为以下几个阶段：

1.  **词法分析**
2.  **语法分析**
3.  **语义分析**
4.  **优化**
5.  **目标代码生成**
    下面我们逐一解析每个阶段。

___

### 🌟 总览表

| 阶段                              | 输入             | 输出                               | 主要作用                                               |
| --------------------------------- | ---------------- | ---------------------------------- | ------------------------------------------------------ |
| 1️⃣ 词法分析（Lexical Analysis）    | 源程序（字符流） | 记号流/标记流（Token Stream）      | 将源程序的字符序列分解成一个个具有意义的“单词”或“记号” |
| 2️⃣ 语法分析（Syntax Analysis）     | 记号流           | 语法树（或抽象语法树 AST）         | 根据语言的语法规则分析这些记号的结构，判断语法是否正确 |
| 3️⃣ 语义分析（Semantic Analysis）   | 语法树           | 注释语法树（带类型信息、符号表等） | 进行类型检查、作用域检查等，确保语义正确               |
| 4️⃣ 优化（Optimization）            | 中间代码         | 优化后的中间代码                   | 改进程序性能或减少资源占用，不改变程序逻辑             |
| 5️⃣ 目标代码生成（Code Generation） | 优化后的中间代码 | 可执行目标代码或汇编代码           | 将中间表示转换为机器能执行的目标代码                   |

### 🧩 1️⃣ 词法分析（Lexical Analysis）

#### ✅ 工作过程：

编译器从左到右**逐个字符**读取源代码，识别出有意义的“单词”（称为**记号 Token**）。
 空格、换行、注释会被忽略。

##### 🔹 输入：

```js
result = (a + 10) * 5;
```

##### 🔹 输出（记号流 Token Stream）：

| 类型        | 内容   | 说明             |
| ----------- | ------ | ---------------- |
| Identifier  | result | 标识符（变量名） |
| Operator    | =      | 赋值运算符       |
| Punctuation | (      | 左括号           |
| Identifier  | a      | 标识符           |
| Operator    | +      | 加号             |
| Number      | 10     | 整型常量         |
| Punctuation | )      | 右括号           |
| Operator    | *      | 乘号             |
| Number      | 5      | 整型常量         |
| Punctuation | ;      | 分号（语句结束） |

#### 🧠 阶段结果（词法分析器输出）：

```css
[result][=][(][a][+][10][)][*][5][;]
```

------



### 🧩 2️⃣ 语法分析（Syntax Analysis）

#### ✅ 工作过程：

语法分析阶段接收词法分析产生的标记流，并根据编程语言的**语法规则**（通常用上下文无关文法描述）来检查这些标记的组合是否合法。它的核心任务是构建一个树形结构，称为**抽象语法树（AST）**，来表示程序的层次结构。

##### 🔹 输入：

来自词法分析器的**记号流（Token Stream）**

##### 🔹 输出：

**抽象语法树（AST）**

##### 🔹 对应的 AST（树形结构）：

```mathematica
         (=)
        /   \
   (result)   (*)
           / \
         (+)  (5)
         / \
       (a)  (10)
```

> 这个树状结构清晰地表明了运算的优先级：先计算 `a + 10`，然后将结果与 `5` 相乘，最后赋值给 `result`。如果代码写成 `result = a + 10 * 5;`，AST的结构会不同，体现了乘法优先于加法的语法规则。

##### 🔹 说明：

- 根节点 `=` 表示赋值运算；
- 左子树是变量 `result`；
- 右子树是乘法表达式 `((a + 10) * 5)`；
- 括号只是影响语法结构，在 AST 中不再保留。

------



### 🧩 3️⃣ 语义分析（Semantic Analysis）

#### ✅ 工作过程：

语法分析只保证了代码结构正确，语义分析器检查这棵 AST 是否**符合语言的语义规则**，并为每个符号附加类型信息。例如：变量必须已定义、类型要匹配、操作合法。

##### 🔹 输入：

来自语法分析器的**抽象语法树 (AST)**。

##### 🔹 主要检查：

| 检查项       | 示例                                | 说明                   |
| ------------ | ----------------------------------- | ---------------------- |
| 变量声明     | `a`, `result` 必须已定义            | 否则报“未定义变量”错误 |
| 类型匹配     | `a + 10` 中 `a` 必须是数值类型      | 确保 `+` 运算合法      |
| 赋值类型匹配 | `result` 的类型与右边表达式类型一致 | 避免类型错误           |

##### 🔹 输出：

带有类型和作用域信息的 **AST** ，或者更常见的，一种**中间代码**。**符号表（Symbol Table）**也是一个重要的产物。

**符号表示例：**

| 名称   | 类型 | 作用域 | 地址   |
| ------ | ---- | ------ | ------ |
| a      | int  | global | 0x1000 |
| result | int  | global | 0x1004 |

------



### 🧩 4️⃣ 优化阶段（Optimization）

#### ✅ 工作过程：

在不改变程序语义的前提下，**简化或改进中间代码**，提升执行效率。这是一个可选但非常重要的阶段，现代编译器都包含了复杂的优化算法。

##### 🔹 输入：

来自语义分析阶段的中间代码（IR, Intermediate Representation）

##### 🔹 生成中间代码（未优化）：

```js
t1 = a + 10
t2 = t1 * 5
result = t2
```

##### 🔹 优化后中间代码：

- 常量折叠、寄存器分配、公共子表达式消除等。

本例中 `(a + 10) * 5` 没有复杂优化空间，但可能会：

- 合并中间变量；
- 提前分配寄存器。

------



### 🧩 5️⃣ 目标代码生成（Code Generation）

#### ✅ 工作过程：

这是编译的最后一个阶段。它将优化后的中间代码翻译成**特定目标机器**的**汇编语言或机器语言**。这个阶段需要考虑**目标机器**的硬件架构，如CPU指令集、寄存器数量、内存寻址方式等。

##### 🔹 输入：

**优化后的中间代码**以及**符号表**中的信息。

```ini
t1 = a + 10
t2 = t1 * 5
result = t2
```

##### 🔹 输出（假设是 x86 汇编代码）：

```assembly
MOV EAX, [a]      ; 将变量a读入寄存器EAX
ADD EAX, 10       ; EAX = a + 10
IMUL EAX, 5       ; EAX = (a + 10) * 5
MOV [result], EAX ; 将结果写回result
```

> 这个汇编代码就是CPU最终可以理解和执行的指令（在经过链接器处理后）。

##### 🔹 最终生成：

机器代码（0101...）或可执行文件（.exe / .out）

------

### 🧭 六、完整流程总览图

```sql
源代码：result = (a + 10) * 5;
  ↓
[词法分析]
→ Token 流：[result][=][(][a][+][10][)][*][5][;]
  ↓
[语法分析]
→ AST：树形结构表达式
  ↓
[语义分析]
→ 检查类型与符号表，附加类型信息
  ↓
[优化]
→ 中间代码简化：t1=a+10; t2=t1*5; result=t2;
  ↓
[目标代码生成]
→ 汇编代码 / 机器代码
```





词法、语法、语义分析阶段就像我们阅读一篇文章时，依次进行的**拼写检查**、**语法检查**和**逻辑含义检查**。每个阶段都有其明确的职责，因此能检查出的错误类型也各不相同。

下面我们详细介绍每个阶段可以检查的错误类型，并举例说明。

### 🧩 一、词法分析阶段（Lexical Analysis）

#### 🔹 检查内容：

- 源代码中是否存在**非法字符**、**不符合语言规则的标识符**或**字符串未闭合**等词法错误。

#### 🔹 能发现的错误类型：

| 错误类型       | 说明                       | 示例                       |
| -------------- | -------------------------- | -------------------------- |
| 非法字符       | 出现编译器无法识别的字符   | `int $x = 5;`（`$`非法）   |
| 不合法的标识符 | 以数字开头、或包含非法符号 | `int 3num = 5;`            |
| 字符串未闭合   | 缺少引号                   | `char* s = "hello;`        |
| 注释未闭合     | 注释块没有结束             | `/* this is a comment`     |
| 数字格式错误   | 如错误的小数点或进制格式   | `float x = 12.;` 或 `0xG4` |

#### 🔹 举例：

```C
int main() {
  int 3a = 10;  // ❌ 错误：标识符不能以数字开头
}
```

🔸 **在词法分析阶段就会报错**：非法的标识符。

------



### 🧩 二、语法分析阶段（Syntax Analysis）

#### 🔹 检查内容：

- 程序结构是否符合**语言的语法规则（文法）**。
- 比如语句是否缺少分号、括号匹配是否正确、表达式结构是否合法等。

#### 🔹 能发现的错误类型：

| 错误类型       | 说明                   | 示例                               |
| -------------- | ---------------------- | ---------------------------------- |
| 缺少分号、括号 | 语句不完整             | `if (x > 0 { y = 1; }`（缺右括号） |
| 表达式结构错误 | 运算符或操作数位置不当 | `a + * b;`                         |
| 控制结构错误   | 关键字不匹配           | `if (x > 0) y = 1; elsey = 2;`     |
| 缺少语句块     | `{}`使用不当           | `if (x > 0) int y = 1;`            |

#### 🔹 举例：

```C
int main() {
  if (x > 0
    printf("ok");
}
```

🔸 **语法分析阶段报错**：缺少右括号 `)`。

------

### 🧩 三、语义分析阶段（Semantic Analysis）

#### 🔹 检查内容：

- 程序**语法上正确**，但**语义（意义）不符合语言规定**。
- 例如类型不匹配、变量未定义、函数参数错误、作用域错误等。

#### 🔹 能发现的错误类型：

| 错误类型       | 说明                     | 示例                    |
| -------------- | ------------------------ | ----------------------- |
| 变量未定义     | 使用未声明的标识符       | `x = 10;`（`x`未声明）  |
| 类型不匹配     | 操作数或赋值类型不符     | `int a = "hello";`      |
| 函数调用错误   | 参数个数或类型不匹配     | `printf(10, "abc");`    |
| 重定义         | 同一作用域内重复定义变量 | `int a; float a;`       |
| 作用域错误     | 变量超出可见范围         | `{ int a = 1; } a = 2;` |
| 类型转换不允许 | 不合法的强制类型转换     | `(int*)"abc";`          |

#### 🔹 举例：

```C
int main() {
  int x = "hello";  // ❌ 类型不匹配
  y = 5;            // ❌ 未定义变量
  return 0;
}
```

🔸 **语义分析阶段报错**：

- 第 1 行：类型不兼容；
- 第 2 行：变量 `y` 未定义。

------

### 🧭 总结对比表

| 阶段         | 检查重点     | 错误类型               | 示例                      |
| ------------ | ------------ | ---------------------- | ------------------------- |
| **词法分析** | 单词是否合法 | 非法字符、未闭合字符串 | `int 3a = 5;`             |
| **语法分析** | 结构是否合法 | 括号缺失、语法结构错误 | `if (x > 0 { y = 1; }`    |
| **语义分析** | 含义是否合法 | 类型错误、未定义变量   | `int a = "hi";`、`x = 1;` |
