



### pdf上传组件：

一个上传pdf文件的组件

首先是上传，利用的是el-upload组件

```vue
<el-upload
  v-model:file-list="fileList"
  multiple
  accept="application/pdf"
  :limit="5"
  :before-upload="handleBeforeUpload"
  :http-request="handleUpload"
  :on-success="handleSuccess"
  :on-remove="handleRemove"
  :on-exceed="handleExceed"
  :on-error="handleError"
  :on-preview="handlePreview"
>
  <el-button type="primary">点击上传</el-button>
  <template #tip>
    <div class="text-[#939393] text-sm mt-2">
      上传商品描述文件仅支持PDF格式，最多可上传5个、每个大小不超过5M、文件名称需展示在商品详情页，不可过长，建议单个文件名在15汉字以内
    </div>
  </template>
</el-upload>
```

属于自行实现上传文件，然后就是对应的回调函数

```js
// 验证
function validatePdfFile(file) {
  const maxSize = 5 * 1024 * 1024 // 5MB
  const validTypes = ['application/pdf']

  if (file.size > maxSize) {
    ElMessage.warning('pdf文件大小不能超过 5MB')
    return false
  }

  if (!validTypes.includes(file.type)) {
    ElMessage.warning('仅支持 pdf 格式的文件')
    return false
  }

  if (file.name.length > 30) {
    ElMessage.warning('文件名过长，请保持在15个汉字（30字符）以内')
    return false
  }

  return true
}

const handleBeforeUpload = (rawFile) => {
  return validatePdfFile(rawFile)
}

// 上传函数，如果多选也是执行多次，
const handleUpload = async (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)

    addResourceApi(formData)
      .then((data) => {
        console.log('pdf上传完成结果', data)
        resolve(data)
      })
      .catch((error) => {
        reject(error)
      })
  })
}

const handleSuccess = (response, uploadFile, uploadFiles) => {
  console.log('上传成功-----------------')
  console.log('响应', response)

  console.log('pdf数组', fileList.value)

  if (response?.error === 0 && response.resource_id) {
    emits('success', response.resource_id)
  }

  console.log('上传成功-----------------')
}

const handleRemove = async (uploadFile, uploadFiles) => {
  console.log('删除文件===============')
  console.log('文件', uploadFile)

  const id = uploadFile.response.resource_id
  const res = await deleteResourceApi(id)
  if (res) {
    ElMessage.success('删除成功')
    console.log('res  deleted', res)
  }
  emits('delete', id)
  console.log('删除文件===============')
}
const handleError = (error, uploadFile, uploadFiles) => {
  console.error(error)
  ElMessage.error('上传失败')
}

const handleExceed = () => {
  ElMessage.warning('文件超出数量，请重新选择后上传')
  return
}

//预览，点击打开新窗口
const handlePreview = (file) => {
  if (file.url) {
    window.open(file.url, '_blank')
  } else if (file.raw) {
    const blobUrl = URL.createObjectURL(file.raw)
    window.open(blobUrl, '_blank')
  } else {
    ElMessage.warning('该文件暂时无法预览')
  }
}
```



父组件中使用这个组件：

```vue
<PdfUpload :uploadedIds="productForm.docums"  @success="handlePdfSuccess" @delete="handlePdfDelete"></PdfUpload>
```

父组件中会通过网络请求获取当前的商品数据，获取以后会修改`productForm.docums`，是一个数组，内部的`id`表示已经上传的`pdf`的`id`
`:uploadedIds="productForm.docums"`的目的时为了把这些`id`传递给子组件，回显出来。



问题：

假如在父组件中获取到`productForm.docums=1,2,3]`，传递给子组件，子组件进行回显，更新了`fileList = [1,2,3]`

回显以后，我进行删除一个文件，删除以后，发送删除文件的`id=1`给父组件，子组件的`fileList=[2,3]`

父组件中收到以后执行`handlePdfDelete` , 修改了`productForm.docums = [2,3]`，这时候又重新传递给子组件`fileList=[2,3]`





用到promise.all()的原因是：

这个上传pdf的组件，还要支持回显已经上传的文件，传递给这个组件的是一个id数组，这个数组是已经上传的文件，要根据这个数组请求文件，修改v-model绑定的fileList数组。





子组件内部定义了prop，父组件传递过来，子组件内部监听了prop，组件内部会有一些事件通知给父组件，让父组件更新传递来的数据，一旦父组件的数据更新，传递给子组件的数据也更新了，子组件的watch就会再次执行。但是我希望只有最初传递有效值的时候，执行一次watch，之后即使更新了，也不再执行watch



头像上传的逻辑

上传文件必须使用FormData:

因为上传文件时，我们要用 HTTP 协议里的 `multipart/form-data` 类型，把**文件**和**其它字段**一起打包给后端，而 `FormData` 正是浏览器为这个目的准备的原生接口。

`Content-Type` 会被 Axios 自动识别并加上 `multipart/form-data`（不需要手动设置）。



使用`el-upload`组件，用户从本地选择图片以后，自动上传到后端服务器对应的接口，在`on-success`回调中，可以获取到服务器返回的响应，通常是返回的url地址，我们把这个url地址放到前端的上传图片的数组中就行了







当你在 `<el-upload>` 中选择文件（通过本地或拖拽）时，只要：

- 文件格式被 `accept` 接受
- 未超出 `limit` 限制
- `before-upload` 没有返回 `false`
- `on-exceed` 没有阻止上传

Element Plus 就会把这些文件**临时添加**到内部的上传队列，并触发你绑定的 `v-model:file-list`。

这时候 `imageList.value` **会立即变成包含待上传文件的数组**，即使文件还没真正上传完成。每个文件是一个包含 `uid`、`name`、`status`、`raw` 等字段的对象。



#### `on-success` 回调

```js
on-success = (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void
```

| 参数名        | 类型            | 含义                                                         |
| ------------- | --------------- | ------------------------------------------------------------ |
| `response`    | `any`           | 后端接口返回的数据。通常是上传接口响应的 JSON 数据。         |
| `uploadFile`  | `UploadFile`    | 当前**上传成功的文件对象**，包含文件名、URL、状态等信息。    |
| `uploadFiles` | `UploadFiles[]` | 当前上传组件中维护的**所有文件列表**，包括成功、失败、上传中的文件。 |

`uploadFile` 对象的常用字段：

```js
UploadFile = {
  name: string;
  url?: string;
  status?: 'success' | 'ready' | 'uploading' | 'fail';
  percentage?: number;
  raw?: File; // 原始 File 对象
  uid: number | string;
  size?: number;
  type?: string;
  response?: any; // 后端返回结果
}
```

配合 `list-type="picture-card"` 显示图片，`uploadFile.url` 就是关键字段，用来展示图片用



##### `uploadFile.response` 是什么？

`uploadFile` 对象里也有一个 `response` 字段，它是 **Element Plus 内部在上传成功时自动赋值的**，保存的是你上传文件后服务器返回的内容。

**它和 `on-success` 回调中的第一个参数 `response` 是一样的内容**，Element Plus 自动帮你记录了一份。

主要是为了 **让你在别的地方（不在 `on-success` 回调中）也能拿到上传成功后的后端返回信息**，比如：

自定义 `fileList` 渲染时使用返回的数据



#### 多图上传

当你配置了 `el-upload` 允许多张图片上传（例如 `multiple` 或拖拽上传），**每一张上传成功的图片都会单独触发一次** `on-success` 回调。





#### `v-model:file-list="fileList"` 的作用

- `fileList` 是你**手动绑定上传组件内部维护的文件列表**。
- 它的格式和 `uploadFiles` 一样，数组中每一项是 `UploadFile`。

| **名称**                      | **描述**     | **类型** | **类型**         | **默认值** |
| ----------------------------- | ------------ | -------- | ---------------- | ---------- |
| file-list / v-model:file-list | 默认上传文件 | object   | UploadUserFile[] | []         |





```ts
// 类型文件位置：node_modules/element-plus/es/components/upload/src/upload.d.ts

export interface UploadFile {
    name: string;
    percentage?: number;
    status: UploadStatus;
    size?: number;
    response?: unknown;
    uid: number;
    url?: string;
    raw?: UploadRawFile;
}
```

根据这个类型声明文件，貌似只需要设置`name`,`status`,`uid`这几个必须的属性就可以了。

经过测试，只设置一个`name`属性也可以回显，但是只是能**让文件名在列表中展示**，但**不会显示文件预览图标或支持点击打开预览**，也不具备完整的回显体验。

![image-20250606095313870](./typora-pic/image-20250606095313870.png)

如果是点击打开pdf，或者是图片需要预览，这种只设置`name`属性，是不可以的。



回显效果对比说明：

| 情况              | 是否显示文件名 | 是否可点击预览（如 PDF 图标 或 PDF 查看） | 说明                                      |
| ----------------- | -------------- | ----------------------------------------- | ----------------------------------------- |
| 只设置 `name`     | ✅              | ❌                                         | 只能看到文字名称，像个“伪上传项”          |
| 设置 `name + url` | ✅              | ✅                                         | 推荐用法，Element Plus 会自动展示预览链接 |
| 设置 `raw: File`  | ✅              | ✅（内部用 URL.createObjectURL）           | 适用于本地上传的文件                      |
| 没有 `name`       | ❌              | ❌                                         | 完全不会显示                              |

✅ 推荐回显写法（已上传文件的回显场景）：

```js
fileList.value = [
  {
    name: '上传测试用1.pdf',
    url: 'https://b2b.ebcrack.com/seller.php?mode=resource_dump&resource_id=102',
    status: 'success',
    uid: 102, // 或其他唯一值
  }
]
```

✅ 本地文件上传后回显（用 `raw`）：

```js
fileList.value = [
  {
    name: file.name,
    raw: file,
    status: 'success',
    uid: Date.now()
  }
]
```

Element Plus 会自动使用 `URL.createObjectURL(file.raw)` 来生成 `url`。





使用建议：

**初始化上传文件（编辑页场景）**：

设置`url`字段，编辑时可以直接显示图片

```js
fileList: [
  { name: '已上传图片', url: 'https://example.com/image.jpg' }
]
```



资源回显：

```js
fileList.value.push({
  name: data.name,
  url: `/file/preview?file_key=${data.file_key}`, // 可访问的地址
})
```

**只需要你提供 `name` 和 `url`**，不需要 `raw` 或 `File`。



#### 问题 1：`url` 可以是什么？

> **可以是后端接口地址，也可以是 `URL.createObjectURL(file)` 创建的临时地址。**

- **后端接口地址**：如 `/file/preview?file_key=xxx` 或 `https://cdn.xxx.com/file.pdf`
   👉 适用于你已经上传并存储在服务器上的文件。
- **`URL.createObjectURL(file)`**：是浏览器为本地文件对象创建的临时可访问 URL。
   👉 适用于你还没上传（或刚上传完）但有 `File` 对象的情况。

#### 问题 2：如果没有 `url`，但是有 `raw: File`，**可以回显吗？**

> ✅ **可以。`el-upload` 支持只用 `raw` 字段展示文件。**

- 当你传入 `raw: File`，Element Plus 会自动用 `URL.createObjectURL(raw)` 来生成预览地址。
- 所以，只要你提供了 `raw: File`，就 **可以不用手动写 `url`**，也能预览。



✅ 最佳实践总结

| 情况                        | 是否能回显 | 说明                                  |
| --------------------------- | ---------- | ------------------------------------- |
| 提供了 `url`                | ✅          | 后端文件或本地 Blob URL               |
| 没有 `url` 但有 `raw: File` | ✅          | 会自动使用 `URL.createObjectURL(raw)` |
| 仅有文件名、大小等元信息    | ❌          | 无法回显，没有文件内容或访问路径      |





父组件将自己的树通过prop传递给子组件是，

父组件的数据定义完成就会立刻传递给子组件，子组件收到一次数据

如果父组件数据定义完成，有一些变化，变化以后再次传递给子组件 ，

如果子组件用了v-if控制，那么数据可能只会传递一次



### 多图上传组件：

#### 使用场景：

当前页面加载时要获取已经上传的图片，显示在页面上，后端返回的是资源的`id`构成的数组，比如`[2,23]`，再利用`id`生成`url`，设置到`img`的`src`中。

在当前页面中一方面要显示已经上传的图片，另一方面也可以让删除之前的图片，或者重新上传新的图片。删除和上传图片之后，都会同步的更新父组件中传递的`id`数组。

#### 使用方式：

父组件：

```vue
<MultiImageUpload v-model:ids="uploadIds"></MultiImageUpload>
```

最初在父组件中定义了`uploadIds`，可能是一个`ref`值，也可能是一个响应式变量中的某一个属性，如下：

```js
const uploadIds = ref([])
// 或者
const formData = reactive({
	//...
	uploadIds:[]
})
```

在父组件中会通过网络请求，异步更新这个`uploadIds`，获取到已经上传的图片`id`数组。

**由此可以明确一点：**

传递给子组件的这个`uploadIds`，在最初的时候一定是一个空数组`[]`，之后会通过网络请求更新他，这就有两种情况

1，后端返回的仍然是一个空数组`[]`，即当前没有已经上传的图片，不需要回显

2，后端返回的是非空数组，需要回显已经上传的图片



为了能够拿到传递的`ids`，并回显，子组件就要使用`watch`,监听`props.ids`，目的只是为了回显图片，根据传递的`ids`构建文件对象，添加到`fileList`数组中。

后续的上传图片，element-plus会自动生成文件对象，有url，status，等属性，然后添加到`fileList`数组。

删除图片，也会自动从`fileList`数组删除。

我们需要做的就是上传或者删除以后，获取当前`fileList`中的所有图片的`id`，并同步到父组件中，所以这个`watch`只需要执行一次。



#### 封装子组件：

父组件中通过`v-model:ids`来使用，就需要在子组件中定义`props`，和`emit`

```vue
<template>
  <div>
    <el-upload
      v-model:file-list="fileList"
      list-type="picture-card"
      multiple
      :limit="props.limit"
      :before-upload="handleBeforeUpload"
      :http-request="handleUpload"
      :on-success="handleSuccess"
      :on-remove="handleRemove"
    >
      <el-icon><Plus /></el-icon>
    </el-upload>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  ids: {
    type: Array,
    default: () => []
  },
  /**
   * 文件上传数量限制
   */
  limit: {
    type: Number,
    default: 5
  },
  /**
   * 上传图片格式，默认支持所有图片(image/*)，指定格式示例：'.png,.jpg,.jpeg,.gif,.bmp'
   */
  accept: {
    type: String,
    default: 'image/*'
  },
  /**
   * 最大文件大小（单位：M）
   */
  maxFileSize: {
    type: Number,
    default: 5
  }
})

const emit = defineEmits(['update:ids'])

// 控制文件回显
const fileList = ref([])


// 根据ids，填充一个fileList
// 这个watch 不用考虑初始状态，即不用设置immediate:true，设置了反而麻烦，因为初始状态一定是[]
// 我们只用监听后续的变化： 空，直接停止； 非空， 执行逻辑，然后停止
const stopWatch = watch(
  () => props.ids,
  (newValue) => {
    console.log('子组件ids', newValue)
    if (newValue.length > 0) {
      fileList.value = newValue.map((id) => {
        return {
          uid: Date.now() + id,
          name: id,
          url: `/seller.php?mode=resource_dump&resource_id=${id}`,
          status: 'success',
          resId: id
        }
      })
      console.log('生成fileList', fileList.value)
    }
    // 不论父组件从后端获取并传递的ids，是空数组[],还是非空数组，这个watch只需要执行一次。
    stopWatch()
  }
)


// 从fileList中获取图片ids
function getIds() {
  // return fileList.value.map((item) => item.resId).filter(Boolean)
  return fileList.value.map((item) => item.resId)
}
    
    
/**
 * 限制用户上传文件的格式和大小
 */
function handleBeforeUpload(file) {
  // 校验文件类型：虽然 accept 属性限制了用户在文件选择器中可选的文件类型，但仍需在上传时再次校验文件实际类型，确保符合 accept 的规则
  const acceptTypes = props.accept.split(',').map((type) => type.trim())

  // 检查文件格式是否符合 accept
  const isValidType = acceptTypes.some((type) => {
    if (type === 'image/*') {
      // 如果是 image/*，检查 MIME 类型是否以 "image/" 开头
      return file.type.startsWith('image/')
    } else if (type.startsWith('.')) {
      // 如果是扩展名 (.png, .jpg)，检查文件名是否以指定扩展名结尾
      return file.name.toLowerCase().endsWith(type)
    } else {
      // 如果是具体的 MIME 类型 (image/png, image/jpeg)，检查是否完全匹配
      return file.type === type
    }
  })

  if (!isValidType) {
    ElMessage.warning(`上传文件的格式不正确，仅支持：${props.accept}`)
    return false
  }

  // 限制文件大小
  if (file.size > props.maxFileSize * 1024 * 1024) {
    ElMessage.warning('上传图片不能大于' + props.maxFileSize + 'M')
    return false
  }
  return true
}
// 上传函数，如果多选也是执行多次，
const handleUpload = async (options) => {
  return new Promise((resolve, reject) => {
    const file = options.file

    const formData = new FormData()
    formData.append('resource_file', file)

    addResourceApi(formData)
      .then((data) => {
        console.log('image上传完成', data)
        resolve(data)
      })
      .catch((error) => {
        reject(error)
      })
  })
}

// 一次上传两张时 第一张发送的emit的有两个值，且后一个为undefined
const handleSuccess = (response, uploadFile, uploadFiles) => {
  console.log('上传成功-----------------')
  console.log('响应', response)
  console.log('uploadFile', uploadFile)
  console.log('fileList', fileList.value)

  if (response?.resource_id) {
    const matched = fileList.value.find((f) => f.uid === uploadFile.uid)
    if (matched) {
      matched.resId = response.resource_id
      matched.name = response.name
      // matched.url = `/seller.php?mode=resource_dump&resource_id=${response.resource_id}`
    }
    const ids = getIds()
    emit('update:ids', ids)
  }

  console.log('上传成功-----------------')
}

const handleRemove = async (uploadFile) => {
  console.log('删除文件', uploadFile)
  const id = uploadFile.resId
  if (!id) {
    ElMessage.warning('没有可删除的图片')
    return
  }
  const res = await deleteResourceApi(id)
  if (res) {
    ElMessage.success('删除成功')
    const ids = getIds() 
    emit('update:ids', ids)
      
    // 无效代码  
    // 等 fileList 更新后再取 ids、 这时候fileList中还是存在那张应该被删除的图片的
    // nextTick(() => {
    //   const ids = getIds()
    //   emit('update:ids', ids)
    // })
  }
}

</script>
```

`handleRemove` 中不需要使用 `nextTick`，`fileList` 会在 `onRemove` 钩子触发前就已同步更新完成。

`el-upload` 的 `on-remove` 生命周期钩子触发顺序如下：

1. 用户点击删除按钮；
2. `fileList` 中对应项已被移除；
3. 然后才执行你绑定的 `handleRemove(uploadFile)` 方法；
4. 所以此时 `fileList.value` 已经是最新的状态。
