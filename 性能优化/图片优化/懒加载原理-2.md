图片懒加载（Lazy Loading）的核心逻辑是**“按需加载”**，即：**优先加载用户当前看得到的内容，推迟加载用户看不到的内容。**

它主要优化的核心性能指标是 **首屏加载速度（FCP/LCP）** 和 **网络资源利用率**。

以下是详细的对比分析，解释了它到底优化了什么，以及为什么会有这些优势：

### 1. 核心优化的性能问题

#### A. 首屏加载时间 (FCP - First Contentful Paint / LCP - Largest Contentful Paint)
*   **问题**：如果页面有大量图片（如电商列表、长文章），浏览器默认会并发下载所有图片。这会占用大量的网络带宽，导致 CSS、JS 和首屏的关键图片（Banner 等）下载变慢，用户看到白屏或页面布局混乱的时间变长。
*   **优化**：懒加载将非首屏图片的请求“让路”，让带宽资源优先服务于首屏内容。

#### B. 网络请求并发限制 (HTTP Concurrency)
*   **问题**：浏览器对同一个域名下的并发请求数量是有限制的（通常 Chrome 是 6 个）。如果有 100 张图片同时请求，它们会排队，导致关键资源（如页面逻辑 JS、核心 CSS）被阻塞在队列后面。
*   **优化**：懒加载减少了初始时刻的并发请求数，避免了网络拥堵。

#### C. 资源浪费 (Bandwidth Wastage)
*   **问题**：很多用户打开页面看了一眼就关闭了（跳出率高），或者根本不会滚动到底部。如果一次性加载所有图片，那些未被浏览的图片消耗的流量和服务器带宽就纯粹是浪费。
*   **优化**：只有当用户滚动到那里时才下载，节省了用户的流量，也节省了公司的 CDN/服务器带宽成本。

#### D. 浏览器渲染压力 (Main Thread Blocking)
*   **问题**：图片不仅仅是下载，下载后浏览器还需要解码（Decoding）和绘制。大量图片同时解码会占用 CPU 和内存，可能导致页面初始化时掉帧或卡顿。
*   **优化**：分散了解码和绘制的压力，不再集中在页面加载的那一瞬间。

---

### 2. 对比分析：不采用 vs 采用懒加载

我们可以把页面加载比作**“去餐厅吃饭”**：

*   **不采用懒加载**：就像你一坐下，服务员把你点的 **开胃菜、主食、甜点、饮料（共20道菜）** 一瞬间全部端上桌。
    *   **后果**：桌子放不下（内存占用高），你也吃不过来，而且为了等最后一道菜做好，你连第一口水都喝不上（首屏慢）。如果你吃两口就走了，剩下的菜全浪费了（流量浪费）。

*   **采用懒加载**：像吃法餐，**先上开胃菜（首屏）**，等你吃完了，**再上一道菜（滚动加载）**。
    *   **后果**：桌子很清爽，你马上就能开始吃（首屏快），如果不吃了随时走人，也不浪费后面的菜。

#### 具体技术维度对比如下：

| 维度             | **不采用懒加载 (Standard Loading)**                          | **采用懒加载 (Lazy Loading)**                               | **优势解析**                                            |
| :--------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :------------------------------------------------------ |
| **关键渲染路径** | 浏览器尝试同时下载 CSS、JS 和**所有**图片。带宽被非关键图片抢占。 | 浏览器优先下载 CSS、JS 和**首屏**图片。非首屏图片暂不请求。 | **首屏渲染更快**，用户能更快看到完整的第一屏内容。      |
| **网络请求**     | 初始化时发出大量 HTTP 请求，可能触发浏览器并发限制，导致请求排队阻塞。 | 初始化请求数极少，只有滚动页面时才分批发出请求。            | **避免网络拥堵**，关键资源不被阻塞。                    |
| **流量消耗**     | 无论用户看没看，消耗 100% 的图片流量（例如 10MB）。          | 用户看多少，消耗多少（例如只看了首屏，仅消耗 0.5MB）。      | **省钱**（用户省流量，服务器省带宽费）。                |
| **内存与CPU**    | 浏览器需一次性将所有图片解码并存入内存，低端设备容易卡顿或崩溃。 | 图片分批解码，内存占用平稳，CPU 峰值低。                    | **页面操作更流畅**，减少设备发热和卡顿。                |
| **DOM 解析**     | 浏览器知道所有 `img` 的 `src`，立即开始布局计算。            | 初始 `src` 为空或占位图，滚动时动态修改 `src`。             | 虽然懒加载涉及 DOM 操作，但避免了初始的大规模渲染计算。 |

---

### 3. 为什么懒加载能优化？（底层逻辑）

懒加载之所以能优化性能，是因为它遵循了前端性能优化的黄金法则：**Defer non-critical assets (推迟非关键资源的加载)。**

浏览器在解析 HTML 时，它是“贪婪”的，只要看到 `<img src="...">`，它就会认为这是必须展示的资源而去请求。懒加载通过技术手段（如先把地址存在 `data-src` 里，或者用 `loading="lazy"` 告诉浏览器）欺骗或通知浏览器：“这个资源现在不重要，先别管它”。

**只有当资源变得“关键”（进入视口，用户即将看到）时，才去加载它。**

### 4. 特别注意：懒加载的误区

虽然懒加载优势巨大，但在一种情况下**不能**使用懒加载：

*   **首屏的主图（LCP 元素）不要懒加载！**
    *   如果你给页面最上面的大图（Banner）加了 `loading="lazy"`，浏览器会认为它不重要，推迟加载它，结果反而导致用户看到首屏大图的时间变慢，降低了 LCP 得分，影响 SEO 和用户体验。
    *   **最佳实践**：首屏图片正常加载（甚至使用 `<link rel="preload">` 预加载），首屏以下的图片全部懒加载。









从影响FCP的角度来说，浏览器默认并发下载所有图片，那么下载图片资源时，是不是会阻塞DOM树的构建，如果结合浏览器的渲染过程，下载所有图片会影响到渲染过程中的哪些步骤



这是一个非常深刻且触及浏览器底层机制的问题。

直接回答你的结论：**图片资源的下载本身并不会阻塞 DOM 树的构建（DOM Tree Construction）。**

HTML 解析器（Parser）在遇到 `<img>` 标签时，会向网络层发起请求，然后**继续向下解析** HTML，不会停下来等待图片下载完成。

但是，**“不阻塞 DOM 构建”不代表“不影响 FCP（首屏渲染时间）”**。如果不采用懒加载，并发下载所有图片会通过**网络拥堵**和**主线程占用**两个维度，严重拖慢渲染流水线中的其他步骤，从而导致 FCP 变慢。

以下结合**浏览器渲染原理（Critical Rendering Path）**，详细分析并发下载图片到底拖累了哪一步：

---

### 1. 网络层面的影响（最直接的 FCP 杀手）
**影响阶段：关键资源请求 (Request Critical Resources)**

虽然图片不阻塞 DOM，但**带宽是有限的**，TCP 连接数也是有限的。

*   **资源争抢（Resource Contention）**：
    浏览器需要下载 CSS、JS、字体文件等**关键渲染资源（Critical Resources）**才能开始渲染。
    *   如果不懒加载，浏览器一瞬间发起几十个图片请求。
    *   虽然现代浏览器有资源优先级（Resource Hints），通常会优先下载 CSS/JS，但在网络带宽有限（如移动端 4G/3G）的情况下，大量的图片数据包依然会挤占带宽，导致 CSS 和 JS 的下载速度变慢。
*   **后果**：
    *   **CSSOM 构建延迟**：CSS 下载慢了，CSSOM（CSS 对象模型）就无法及时构建完成。
    *   **渲染阻塞**：**DOM 树和 CSSOM 树必须合并成渲染树（Render Tree）才能开始布局和绘制**。虽然 DOM 建好了，但因为 CSS 没回来，浏览器不敢渲染（防止无样式内容闪烁 FOUC）。
    *   **结论**：图片抢占带宽 -> 拖慢 CSS 下载 -> 阻塞 Render Tree 合成 -> **推迟 FCP**。

---

### 2. 布局阶段的影响 (Layout / Reflow)
**影响阶段：布局 (Layout)**

当图片资源被下载时，浏览器需要知道它们的大小来计算页面布局。

*   **无尺寸的布局抖动**：
    如果 HTML 中的 `<img>` 标签没有设置明确的 `width` 和 `height`，浏览器在图片下载前不知道其大小，会先在 Render Tree 中给它预留 0x0 或默认大小的空间。
*   **频繁的回流（Reflow）**：
    如果不懒加载，大量图片在短时间内陆续下载完成。每下载好一张，浏览器发现图片实际尺寸（比如 500x300），就必须推翻之前的布局，重新计算整个页面的几何位置。
*   **后果**：
    *   主线程（Main Thread）被频繁的 Layout 计算任务占用。
    *   FCP 虽然主要看第一帧，但在渲染初期频繁触发重排，会消耗 CPU 资源，导致浏览器“忙不过来”，无法及时将像素绘制到屏幕上。

---

### 3. 绘制与合成阶段的影响 (Paint & Composite)
**影响阶段：光栅化与解码 (Rasterization & Decoding)**

这是最容易被忽视的一点。图片下载下来是二进制数据（JPG/PNG），必须经过**解码（Decode）**变成位图（Bitmap）才能交给 GPU 绘制。

*   **解码占用主线程**：
    图片解码是一个非常耗费 CPU 的操作。如果不懒加载，几十张图片并发下载并陆续完成，浏览器就需要连续不断地解码这些图片。
*   **光栅化压力**：
    即使这些图片在视口之外（用户还看不到），如果浏览器逻辑不够优化，它可能会尝试预先绘制这些内容（Composite Layers），占用显存和 GPU 带宽。
*   **后果**：
    *   主线程被“图片解码”任务塞满。
    *   当用户的主 JS 代码想要执行（比如处理点击事件），或者浏览器想要绘制首屏文字时，发现主线程在忙着解码第 50 张图片（还在页脚呢）。
    *   这会导致**长任务（Long Tasks）**，引起页面卡顿，推迟首屏内容的呈现（FCP）。

---

### 总结：全景图

如果不采用懒加载，浏览器渲染流水线受到的打击如下：

1.  **HTML 解析 (Parse HTML)**：
    *   ✅ **不阻塞**。DOM 树正常构建。
2.  **网络请求 (Network)**：
    *   ❌ **严重阻塞**。非关键图片抢占带宽，导致关键 CSS/JS/字体 下载变慢。
3.  **CSSOM 构建**：
    *   ❌ **被动延迟**。因为 CSS 下载慢了，导致 Render Tree 无法生成。
4.  **布局 (Layout)**：
    *   ⚠️ **繁忙**。如果图片未定高宽，下载完成会触发多次回流。
5.  **绘制 (Paint) & 合成**：
    *   ❌ **主线程阻塞**。大量图片解码任务占用 CPU，导致首屏绘制任务排队，延迟 FCP。

### 结论
懒加载之所以能优化 FCP，**本质上不是因为“减少了 DOM 节点”，而是因为“腾出了带宽给关键 CSS/JS”以及“腾出了 CPU 给首屏内容的解码和绘制”**。它确保了浏览器把最宝贵的资源（带宽、CPU、GPU）全部集中在用户眼睛当前盯着的那块屏幕上。