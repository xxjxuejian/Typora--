## 一句话先给结论（先稳住）

- **preload**：
  👉 **“这个资源等会儿一定要用，你现在就给我快点下载！”**
  → **当前页面、当前流程的关键资源**
- **prefetch**：
  👉 **“这个资源可能以后会用，先有空就顺手下了吧。”**
  → **未来页面 / 未来场景的资源**

一句话对照表：

| 点           | preload                      | prefetch               |
| ------------ | ---------------------------- | ---------------------- |
| 用途         | 当前页面必用                 | 未来可能用             |
| 紧急程度     | 高（很急）                   | 低（不急）             |
| 浏览器优先级 | 高                           | 低                     |
| 典型场景     | 首屏字体 / 关键 JS / hero 图 | 下一个路由的 JS / 图片 |

------

## preload：**“我马上就要用！”**

### 你可以把 preload 当成：

> **手动告诉浏览器：这东西很重要，别等解析到再下**

### 典型例子

```html
<link rel="preload" href="/main.js" as="script">
<link rel="preload" href="/font.woff2" as="font" crossorigin>
```

### 浏览器视角发生了什么？

1. HTML 还在解析中
2. 浏览器看到 `<link rel="preload">`
3. **立刻、以高优先级开始下载**
4. 等真正用到时（`<script>` / `@font-face`），
   👉 **直接从缓存拿，不用再等**

### 为什么它很“猛”？

因为正常情况下：

- JS / 字体 / 图片
  都是 **解析到对应标签才开始下载**
- preload = **提前抢跑**

### 但要小心 ⚠️

> preload 是把“调度权”从浏览器手里抢过来

如果你：

- preload 了一个**根本没用的资源**
- 或 preload 太多

👉 会 **挤占带宽**，反而拖慢首屏
所以它是个**高级工具**，不是“多多益善”。

------

## prefetch：**“以后也许会用”**

### prefetch 更像：

> **浏览器空闲时的“囤货行为”**

```html
<link rel="prefetch" href="/detail.chunk.js" as="script">
```

### 浏览器视角：

1. 当前页面关键资源都下载完了

2. 网络比较空

3. 浏览器：

   > “欸，这个可能以后用，那我现在顺手下了吧”

4. 放进 cache（优先级很低）

### 常见场景

- SPA 中：
  - 首页 → 详情页
  - 列表页 → 编辑页
- 路由级代码分割

```ts
// Vite / Webpack 都会自动加 prefetch
const Detail = () => import("./Detail.vue");
```

你点“下一页”的那一刻：
👉 JS **已经在缓存里了**，几乎秒开

------

## 时间线直觉图（很重要）

假设你现在在 **首页**：

```css
时间 →
HTML 解析
│
├─ preload：现在立刻下载（高优先级）
│
├─ 首屏渲染 / JS 执行
│
├─ 页面空闲
│
└─ prefetch：有空再下载（低优先级）
```

**一句话理解：**

- preload = **插队**
- prefetch = **等没人排队了再来**

------

## 和你之前聊过的性能指标，能对上吗？

结合你关心的那条时间线 👇

- **preload**
  - 可能提升：**LCP / FCP**
  - 因为关键资源更早可用
- **prefetch**
  - 不影响当前页 LCP
  - 但会极大提升：
    - 下一页的 **TTI**
    - 路由切换的“丝滑感”

------

## 一个很“工程化”的经验判断 🧠

你在项目里可以这样问自己：

> **“这个资源，如果晚 100ms 才到，会不会影响用户当前看到的东西？”**

- 会 👉 **preload**
- 不会，只是下一个操作才用 👉 **prefetch**
- 根本不确定 👉 **交给浏览器（别乱加）**

------

## 最后一个小呆萌总结 🐣

- preload：
  🏃‍♂️“我要上场了，现在就给我球！”
- prefetch：
  🧺“等会儿可能要用，先放篮子里吧”

