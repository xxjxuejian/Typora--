JavaScript 的事件循环（Event Loop）是理解 JS 执行机制的核心。因为 JavaScript 是**单线程**的，它需要一种机制来处理异步操作（如网络请求、定时器），而不会阻塞主线程。

下面我为你详细梳理 **执行机制**、**宏任务与微任务的区别**，并通过**代码示例**来演示执行顺序。

---

### 1. 核心概念：宏任务与微任务

JavaScript 把异步任务分为两类，它们的优先级不同：

#### **微任务 (Micro-tasks)**
*   **特点**：优先级高，在当前宏任务结束之前、下一次渲染之前执行。
*   **常见来源**：
    *   `Promise.then` / `.catch` / `.finally`
    *   `async/await` (本质也是 Promise)
    *   `MutationObserver` (浏览器环境)
    *   `queueMicrotask`
    *   `process.nextTick` (Node.js 环境，优先级最高，比普通微任务还快)

#### **宏任务 (Macro-tasks)**
*   **特点**：优先级低，每次事件循环只执行一个宏任务，然后检查微任务队列。
*   **常见来源**：
    *   整体代码脚本 (`script` 标签)
    *   `setTimeout`
    *   `setInterval`
    *   `setImmediate` (Node.js)
    *   I/O 操作、UI 渲染

---

### 2. 事件循环的执行流程 (The Loop)

请记住这个**“金科玉律”**：

1.  **执行同步代码**（这其实是第一个宏任务）。
2.  同步代码执行完，**立即清空微任务队列**（执行所有微任务，直到队列为空）。
3.  **尝试进行 UI 渲染**（浏览器决定是否需要更新界面）。
4.  **取出下一个宏任务**执行**`（只取一个！只取一个！只取一个！）`**。
5.  **回到第 2 步**（执行完宏任务后，立刻又要去检查微任务）。

**简记口诀：**
> **同步先行，微任务清空，再去搬一个宏任务，周而复始。**

---

### 3. 实战代码分析

#### 基础题：Promise 与 SetTimeout

```javascript
console.log('1'); // 同步

setTimeout(() => {
    console.log('2'); // 宏任务
}, 0);

new Promise((resolve) => {
    console.log('3'); // Promise 构造函数内是同步代码！
    resolve();
}).then(() => {
    console.log('4'); // 微任务
});

console.log('5'); // 同步
```

**执行顺序分析：**

1.  **同步阶段**：
    *   打印 `'1'`。
    *   遇到 `setTimeout`，将其回调放入**宏任务队列**。
    *   遇到 `new Promise`，执行构造函数，打印 `'3'`。
    *   遇到 `.then`，将其回调放入**微任务队列**。
    *   打印 `'5'`。
2.  **清空微任务**：
    *   检查微任务队列，发现 `.then` 的回调，执行并打印 `'4'`。
3.  **执行宏任务**：
    *   取出 `setTimeout` 的回调，执行并打印 `'2'`。

**最终结果**：`1 -> 3 -> 5 -> 4 -> 2`

---

#### 进阶题：Async/Await 与 嵌套

`async/await` 仅仅是 Promise 的语法糖。
*   `await` 这一行右边的代码是**同步**执行的。
*   `await` 下面的代码会被阻塞，相当于放进了 `Promise.then` 中（即**微任务**）。

```javascript
async function async1() {
    console.log('async1 start');
    await async2(); 
    // await 后面的代码相当于放入微任务队列
    console.log('async1 end'); 
}

async function async2() {
    console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});

console.log('script end');
```

**详细推导：**

1.  **第一轮（同步代码 / 宏任务 Script）**：
    *   `console.log('script start')` -> **打印 'script start'**。
    *   `setTimeout` -> 回调放入 **宏任务队列**。
    *   执行 `async1()`：
        *   `console.log('async1 start')` -> **打印 'async1 start'**。
        *   调用 `async2()` -> **打印 'async2'**。
        *   遇到了 `await`，将 `async1` 剩余部分（`console.log('async1 end')`）放入 **微任务队列 (Micro1)**，跳出 `async1` 函数。
    *   执行 `new Promise`：
        *   `console.log('promise1')` -> **打印 'promise1'**。
        *   `resolve()` 触发 `.then`，回调放入 **微任务队列 (Micro2)**。
    *   `console.log('script end')` -> **打印 'script end'**。

    *此时队列状态：*
    *   *微任务：[Micro1 (async1 end), Micro2 (promise2)]*
    *   *宏任务：[setTimeout]*

2.  **清空微任务**：
    *   执行 Micro1：**打印 'async1 end'**。
    *   执行 Micro2：**打印 'promise2'**。

3.  **执行下一个宏任务**：
    *   取出 `setTimeout` 回调：**打印 'setTimeout'**。

**最终结果：**
```text
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```
*(注：在旧版本浏览器中，async/await 的转换机制可能导致 async1 end 比 promise2 慢，但在现代浏览器 V8 引擎中，上述顺序是标准的)*

---

#### 变态题：宏任务中产生微任务

如果宏任务执行过程中，又产生了微任务，怎么办？
**答案：执行完当前这个宏任务后，必须立刻把新产生的微任务全部清空，才能去执行下一个宏任务。**

```javascript
setTimeout(() => {
    console.log('timer1');
    Promise.resolve().then(() => {
        console.log('promise1');
    });
}, 0);

setTimeout(() => {
    console.log('timer2');
}, 0);
```

**执行顺序：**
1.  Script 结束，产生两个宏任务：Timer1, Timer2。
2.  **执行 Timer1**：打印 `'timer1'`。
    *   发现 `Promise.then`，产生一个**微任务**。
    *   Timer1 宏任务结束。
3.  **检查微任务**（插队！）：
    *   发现刚才产生的微任务，执行并打印 `'promise1'`。
4.  **执行 Timer2**：打印 `'timer2'`。

**结果**：`timer1 -> promise1 -> timer2`

---

### 总结

1.  **JavaScript 是单线程的**。
2.  **同步代码** 立即执行。
3.  **微任务 (Promise, await)** 总是比 **宏任务 (setTimeout)** 优先执行。
4.  **微任务队列是“清空制”**：只要微任务队列不空，就一直执行微任务，哪怕是新加进来的。
5.  **宏任务队列是“这就制”**：每次 Loop 只取一个执行，执行完回头看微任务。